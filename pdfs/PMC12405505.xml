


<OAI-PMH xmlns="http://www.openarchives.org/OAI/2.0/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://www.openarchives.org/OAI/2.0/ http://www.openarchives.org/OAI/2.0/OAI-PMH.xsd">
    <responseDate>2025-09-09T13:47:59Z</responseDate>
    <request verb="GetRecord" identifier="oai:pubmedcentral.nih.gov:12405505" metadataPrefix="pmc">https://pmc.ncbi.nlm.nih.gov/api/oai/v1/mh/</request>
    
    <GetRecord>
        <record>
    <header>
    <identifier>oai:pubmedcentral.nih.gov:12405505</identifier>
    <datestamp>2025-09-04</datestamp>
    
        
        <setSpec>ncomms</setSpec>
        
    
        
        <setSpec>pmc-open</setSpec>
        
    
</header>
    <metadata>
        
        <article xmlns="https://jats.nlm.nih.gov/ns/archiving/1.4/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:mml="http://www.w3.org/1998/Math/MathML" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:ali="http://www.niso.org/schemas/ali/1.0/" xsi:schemaLocation="https://jats.nlm.nih.gov/ns/archiving/1.4/ https://jats.nlm.nih.gov/archiving/1.4/xsd/JATS-archivearticle1-4.xsd" article-type="research-article" xml:lang="en" dtd-version="1.4"><processing-meta base-tagset="archiving" mathml-version="3.0" table-model="xhtml" tagset-family="jats"><restricted-by>pmc</restricted-by></processing-meta><front><journal-meta><journal-id journal-id-type="nlm-ta">Nat Commun</journal-id><journal-id journal-id-type="iso-abbrev">Nat Commun</journal-id><journal-id journal-id-type="pmc-domain-id">2873</journal-id><journal-id journal-id-type="pmc-domain">ncomms</journal-id><journal-title-group><journal-title>Nature Communications</journal-title></journal-title-group><issn pub-type="epub">2041-1723</issn><publisher><publisher-name>Nature Publishing Group</publisher-name></publisher></journal-meta><article-meta><article-id pub-id-type="pmcid">PMC12405505</article-id><article-id pub-id-type="pmcid-ver">PMC12405505.1</article-id><article-id pub-id-type="pmcaid">12405505</article-id><article-id pub-id-type="pmcaiid">12405505</article-id><article-id pub-id-type="pmid">40897712</article-id><article-id pub-id-type="doi">10.1038/s41467-025-63214-7</article-id><article-id pub-id-type="publisher-id">63214</article-id><article-version article-version-type="pmc-version">1</article-version><article-categories><subj-group subj-group-type="heading"><subject>Article</subject></subj-group></article-categories><title-group><article-title>Localized statistics decoding for quantum low-density parity-check codes</article-title></title-group><contrib-group><contrib contrib-type="author" corresp="yes" equal-contrib="yes"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-1476-0647</contrib-id><name name-style="western"><surname>Hillmann</surname><given-names initials="T">Timo</given-names></name><address><email>timo.hillmann@rwth-aachen.de</email></address><xref ref-type="aff" rid="Aff1">1</xref></contrib><contrib contrib-type="author" corresp="yes" equal-contrib="yes"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0002-2973-1689</contrib-id><name name-style="western"><surname>Berent</surname><given-names initials="L">Lucas</given-names></name><address><email>lucas.berent@tum.de</email></address><xref ref-type="aff" rid="Aff2">2</xref></contrib><contrib contrib-type="author"><name name-style="western"><surname>Quintavalle</surname><given-names initials="AO">Armanda O.</given-names></name><xref ref-type="aff" rid="Aff3">3</xref></contrib><contrib contrib-type="author"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0003-3033-1292</contrib-id><name name-style="western"><surname>Eisert</surname><given-names initials="J">Jens</given-names></name><xref ref-type="aff" rid="Aff3">3</xref><xref ref-type="aff" rid="Aff4">4</xref></contrib><contrib contrib-type="author"><name name-style="western"><surname>Wille</surname><given-names initials="R">Robert</given-names></name><xref ref-type="aff" rid="Aff2">2</xref><xref ref-type="aff" rid="Aff5">5</xref></contrib><contrib contrib-type="author" corresp="yes"><contrib-id contrib-id-type="orcid" authenticated="false">http://orcid.org/0000-0001-9202-1156</contrib-id><name name-style="western"><surname>Roffe</surname><given-names initials="J">Joschka</given-names></name><address><email>joschka@roffe.eu</email></address><xref ref-type="aff" rid="Aff3">3</xref><xref ref-type="aff" rid="Aff6">6</xref></contrib><aff id="Aff1"><label>1</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/040wg7k59</institution-id><institution-id institution-id-type="GRID">grid.5371.0</institution-id><institution-id institution-id-type="ISNI">0000 0001 0775 6028</institution-id><institution>Chalmers University of Technology, </institution></institution-wrap>Gothenburg, Sweden </aff><aff id="Aff2"><label>2</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/02kkvpp62</institution-id><institution-id institution-id-type="GRID">grid.6936.a</institution-id><institution-id institution-id-type="ISNI">0000000123222966</institution-id><institution>Technical University of Munich, </institution></institution-wrap>Munich, Germany </aff><aff id="Aff3"><label>3</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/046ak2485</institution-id><institution-id institution-id-type="GRID">grid.14095.39</institution-id><institution-id institution-id-type="ISNI">0000 0001 2185 5786</institution-id><institution>Freie Universit&#228;t Berlin, </institution></institution-wrap>Berlin, Germany </aff><aff id="Aff4"><label>4</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/02aj13c28</institution-id><institution-id institution-id-type="GRID">grid.424048.e</institution-id><institution-id institution-id-type="ISNI">0000 0001 1090 3682</institution-id><institution>Helmholtz-Zentrum Berlin f&#252;r Materialien und Energie, </institution></institution-wrap>Berlin, Germany </aff><aff id="Aff5"><label>5</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/02ks3nr96</institution-id><institution-id institution-id-type="GRID">grid.437777.7</institution-id><institution-id institution-id-type="ISNI">0000 0004 0597 2626</institution-id><institution>Software Competence Center Hagenberg, </institution></institution-wrap>Hagenberg, Austria </aff><aff id="Aff6"><label>6</label><institution-wrap><institution-id institution-id-type="ROR">https://ror.org/01nrxwf90</institution-id><institution-id institution-id-type="GRID">grid.4305.2</institution-id><institution-id institution-id-type="ISNI">0000 0004 1936 7988</institution-id><institution>University of Edinburgh, </institution></institution-wrap>Edinburgh, United Kingdom </aff></contrib-group><pub-date pub-type="epub"><day>2</day><month>9</month><year>2025</year></pub-date><pub-date pub-type="collection"><year>2025</year></pub-date><volume>16</volume><issue-id pub-id-type="pmc-issue-id">478256</issue-id><elocation-id>8214</elocation-id><history><date date-type="received"><day>7</day><month>4</month><year>2025</year></date><date date-type="accepted"><day>13</day><month>8</month><year>2025</year></date></history><pub-history><event event-type="pmc-release"><date><day>02</day><month>09</month><year>2025</year></date></event><event event-type="pmc-live"><date><day>04</day><month>09</month><year>2025</year></date></event><event event-type="pmc-last-change"><date iso-8601-date="2025-09-04 00:25:59.930"><day>04</day><month>09</month><year>2025</year></date></event></pub-history><permissions><copyright-statement>&#169; The Author(s) 2025</copyright-statement><copyright-year>2025</copyright-year><license><ali:license_ref specific-use="textmining" content-type="ccbylicense">https://creativecommons.org/licenses/by/4.0/</ali:license_ref><license-p><bold>Open Access</bold> This article is licensed under a Creative Commons Attribution 4.0 International License, which permits use, sharing, adaptation, distribution and reproduction in any medium or format, as long as you give appropriate credit to the original author(s) and the source, provide a link to the Creative Commons licence, and indicate if changes were made. The images or other third party material in this article are included in the article&#8217;s Creative Commons licence, unless indicated otherwise in a credit line to the material. If material is not included in the article&#8217;s Creative Commons licence and your intended use is not permitted by statutory regulation or exceeds the permitted use, you will need to obtain permission directly from the copyright holder. To view a copy of this licence, visit <ext-link ext-link-type="uri" xlink:href="https://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</ext-link>.</license-p></license></permissions><self-uri content-type="pmc-pdf" xlink:href="41467_2025_Article_63214.pdf"/><abstract id="Abs1"><p id="Par1">Quantum low-density parity-check codes are a promising candidate for fault-tolerant quantum computing with considerably reduced overhead compared to the surface code. However, the lack of a practical decoding algorithm remains a barrier to their implementation. In this work, we introduce localized statistics decoding, a reliability-guided inversion decoder that is highly parallelizable and applicable to arbitrary quantum low-density parity-check codes. Our approach employs a parallel matrix factorization strategy, which we call <italic toggle="yes">on-the-fly elimination</italic>, to identify, validate, and solve local decoding regions on the decoding graph. Through numerical simulations, we show that localized statistics decoding matches the performance of state-of-the-art decoders while reducing the runtime complexity for operation in the sub-threshold regime. Importantly, our decoder is more amenable to implementation on specialized hardware, positioning it as a promising candidate for decoding real-time syndromes from experiments.</p></abstract><abstract id="Abs2" abstract-type="web-summary"><p id="Par2">Quantum low-density parity-check (QLDPC) codes offer lower overhead than topological quantum error-correcting codes, but decoding remains a key challenge for scalable fault-tolerant quantum computing. This work introduces a highly parallelizable decoding algorithm for QLDPC codes that matches the accuracy of leading decoders while enabling significantly improved scalability.</p></abstract><kwd-group kwd-group-type="npg-subject"><title>Subject terms</title><kwd>Quantum information</kwd><kwd>Computer science</kwd></kwd-group><funding-group><award-group><funding-source><institution>Chalmers Excellence Initiative Nano and the Knut and Alice Wallenberg Foundation through the Wallenberg Centre for Quantum Technology (WACQT)</institution></funding-source></award-group></funding-group><custom-meta-group><custom-meta><meta-name>pmc-status-qastatus</meta-name><meta-value>0</meta-value></custom-meta><custom-meta><meta-name>pmc-status-live</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>pmc-status-embargo</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-status-released</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-open-access</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-olf</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-manuscript</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-legally-suppressed</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-has-pdf</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-has-supplement</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-pdf-only</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-suppress-copyright</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-is-real-version</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-is-scanned-article</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-preprint</meta-name><meta-value>no</meta-value></custom-meta><custom-meta><meta-name>pmc-prop-in-epmc</meta-name><meta-value>yes</meta-value></custom-meta><custom-meta><meta-name>issue-copyright-statement</meta-name><meta-value>&#169; Springer Nature Limited 2025</meta-value></custom-meta></custom-meta-group></article-meta></front><body><sec id="Sec1" sec-type="introduction"><title>Introduction</title><p id="Par3">Q<italic toggle="yes">uantum low-density parity-check</italic> (QLDPC) codes<sup><xref ref-type="bibr" rid="CR1">1</xref></sup> are a promising alternative to the surface code<sup><xref ref-type="bibr" rid="CR2">2</xref>&#8211;<xref ref-type="bibr" rid="CR4">4</xref></sup>. Based on established methods underpinning classical technologies such as Ethernet and 5G<sup><xref ref-type="bibr" rid="CR5">5</xref>,<xref ref-type="bibr" rid="CR6">6</xref></sup>, QLDPC codes promise a low-overhead route to fault tolerance<sup><xref ref-type="bibr" rid="CR7">7</xref>&#8211;<xref ref-type="bibr" rid="CR13">13</xref></sup>, encoding multiple qubits per logical block as opposed to a single one for the surface code. While, as a trade-off, QLDPC codes require long-range interactions that can be difficult to implement physically, various architectures allow for those requirements<sup><xref ref-type="bibr" rid="CR14">14</xref>&#8211;<xref ref-type="bibr" rid="CR17">17</xref></sup>. In particular, recent work targeting quantum processors based on neutral atom arrays<sup><xref ref-type="bibr" rid="CR13">13</xref></sup> as well a bi-layer superconducting qubit chip architecture<sup><xref ref-type="bibr" rid="CR12">12</xref></sup> suggest that QLDPC codes can achieve an order-of-magnitude reduction in overhead relative to the surface code on near-term hardware.</p><p id="Par4">In a quantum error correction circuit, errors are detected by measuring stabilizers yielding a stream of syndrome information. The <italic toggle="yes">decoder</italic> is the classical co-processor tasked with performing real-time inference on the measured error syndromes to determine a correction operation that must take place within a time frame less than the decoherence time of the physical qubits. Full-scale quantum computers will impose significant demands on their decoders, with estimates suggesting that terabytes of decoding bandwidth will be required for real-time processing of syndrome data<sup><xref ref-type="bibr" rid="CR18">18</xref>,<xref ref-type="bibr" rid="CR19">19</xref></sup>. As such, decoding algorithms must be as efficient as possible and, in particular, suitable for parallel implementation on specialized hardware<sup><xref ref-type="bibr" rid="CR20">20</xref></sup>.</p><p id="Par5">The current gold standard for decoding general QLDPC codes is the <italic toggle="yes">belief propagation plus ordered statistics decoder</italic> (BP+OSD)<sup><xref ref-type="bibr" rid="CR11">11</xref>,<xref ref-type="bibr" rid="CR21">21</xref></sup>. The core of this decoder is the iterative <italic toggle="yes">belief propagation</italic> (BP) algorithm<sup><xref ref-type="bibr" rid="CR22">22</xref></sup> that finds widespread application in classical error correction. Unfortunately, BP decoders are not effective out of the box for QLDPC codes. The reason for this shortcoming are so-called <italic toggle="yes">degenerate errors</italic>, that is, physically different errors that are equivalent up to stabilizers and prevent BP from converging<sup><xref ref-type="bibr" rid="CR11">11</xref>,<xref ref-type="bibr" rid="CR23">23</xref>,<xref ref-type="bibr" rid="CR24">24</xref></sup>. The BP+OSD algorithm augments BP with a post-processing routine based on <italic toggle="yes">ordered statistics decoding</italic> (OSD)<sup><xref ref-type="bibr" rid="CR11">11</xref>,<xref ref-type="bibr" rid="CR21">21</xref>,<xref ref-type="bibr" rid="CR25">25</xref>,<xref ref-type="bibr" rid="CR26">26</xref></sup>. OSD is invoked if the BP algorithm fails to converge and computes a solution by inverting a full-rank submatrix of the parity check matrix. A specific strength of the BP+OSD decoder lies in its versatility: it achieves good decoding performance across the landscape of quantum LDPC codes<sup><xref ref-type="bibr" rid="CR21">21</xref></sup>.</p><p id="Par6">A significant limitation of the BP+OSD decoder is its large runtime overhead. This inefficiency stems primarily from the OSD algorithm&#8217;s inversion step, which relies on Gaussian elimination and has cubic worst-case time complexity in the size of the corresponding check matrix. In practice, this is a particularly acute problem, as decoders must be run on large circuit-level decoding graphs that account for errors occurring at any location in the syndrome extraction circuit. This shortcoming constitutes a known barrier to the experimental implementation of efficient quantum codes, as circuit-level decoding graphs can contain tens of thousands of nodes<sup><xref ref-type="bibr" rid="CR12">12</xref></sup>. Even with specialized hardware, inverting the matrix of a graph of this size cannot realistically be achieved within the decoherence time of a typical qubit<sup><xref ref-type="bibr" rid="CR27">27</xref></sup>. Whilst the BP+OSD decoder is a useful tool for simulations, it is not generally considered a practical method for real-time decoding.</p><p id="Par7">In this work, we introduce <italic toggle="yes">localized statistics decoding</italic> (LSD) as a parallel and efficient decoder for QLDPC codes, designed specifically to address the aforementioned limitations of BP+OSD, while retaining generality and good decoding performance. The key idea underpinning LSD is that in the sub-threshold regime, errors typically span disconnected areas of the decoding graph. Instead of inverting the entire decoding graph, LSD applies matrix inversion independently and concurrently for the individual <italic toggle="yes">sub-graphs</italic> associated with these decoding regions. Similar to OSD, the performance of LSD can be improved using the soft information output of a pre-decoder such as BP. Our numerical decoding simulations of surface codes, bicycle bivariate codes, and hypergraph product codes show that our implementation of the BP+LSD decoder performs on par with BP+OSD in terms of decoding performance.</p><p id="Par8">The efficiency of the LSD algorithm is made possible by a new linear algebra routine, which we call <italic toggle="yes">on-the-fly elimination</italic>, that transforms the serial process of Gaussian elimination into a parallel one. Specifically, our method allows separate regions of the decoding graph to be reduced on separate processors. A distinct feature of on-the-fly elimination lies in a sub-routine that efficiently manages the extension and merging of decoding regions without necessitating the re-computation of row operations. The methods we introduce promise reduced runtime in the sub-threshold regime and open the possibility of using inversion-based decoders to decode real syndrome information from quantum computing experiments. We anticipate that on-the-fly elimination will also find broader utility in efficiently solving sparse linear systems across various settings, such as recommender systems<sup><xref ref-type="bibr" rid="CR28">28</xref></sup> or compressed sensing<sup><xref ref-type="bibr" rid="CR29">29</xref></sup>.</p></sec><sec id="Sec2" sec-type="results"><title>Results</title><sec id="Sec3"><title>The decoding problem</title><p id="Par9">In this paper, we focus on the <italic toggle="yes">Calderbank-Shor-Steane</italic> (CSS) subclass of QLDPC codes. These codes are defined by constant weight Pauli-<italic toggle="yes">X</italic> and -<italic toggle="yes">Z</italic> operators called <italic toggle="yes">checks</italic> that generate the stabilizer group defining the code space. In a gate-based model of computation, the checks are measured using a circuit containing auxiliary qubits and two-qubit Clifford gates that map the expectation value of each check onto the state of an auxiliary qubit. The circuit that implements all check measurements is called the <italic toggle="yes">syndrome extraction circuit</italic>.</p><p id="Par10">For the decoding of QLDPC codes, the decoder is provided with a matrix <inline-formula id="IEq1"><alternatives><tex-math id="d33e398">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$H\in {{\mathbb{F}}}^{| D| \times | F| }$$\end{document}</tex-math><mml:math id="d33e403"><mml:mi>H</mml:mi><mml:mo>&#8712;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mo>&#8739;</mml:mo><mml:mi>D</mml:mi><mml:mo>&#8739;</mml:mo><mml:mo>&#215;</mml:mo><mml:mo>&#8739;</mml:mo><mml:mi>F</mml:mi><mml:mo>&#8739;</mml:mo></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq1.gif"/></alternatives></inline-formula> called the <italic toggle="yes">detector check matrix</italic>. This matrix maps circuit fault locations <italic toggle="yes">F</italic> to so-called <italic toggle="yes">detectors</italic>
<italic toggle="yes">D</italic>, defined as linear combinations of check measurement outcomes that are deterministic in the absence of errors. Specifically, each row of <italic toggle="yes">H</italic> corresponds to a detector and each column to a fault, and <italic toggle="yes">H</italic><sub><italic toggle="yes">d</italic><italic toggle="yes">f</italic></sub>&#160;=&#160;1 if fault <italic toggle="yes">f</italic>&#160;&#8712;&#160;{1,&#160;&#8230;,&#160;&#8739;<italic toggle="yes">F</italic>&#8739;} flips detector <italic toggle="yes">d</italic>&#160;&#8712;&#160;{1,&#160;&#8230;,&#160;&#8739;<italic toggle="yes">D</italic>&#8739;}. Such a check matrix can be constructed by tracking the propagation of errors through the syndrome extraction circuit using a stabilizer simulator<sup><xref ref-type="bibr" rid="CR30">30</xref>&#8211;<xref ref-type="bibr" rid="CR32">32</xref></sup>.</p><p id="Par11">We emphasize that, once the detector matrix <italic toggle="yes">H</italic> is created, the minium-weight decoding problem can be mapped to the problem of decoding a classical linear code: Given a <italic toggle="yes">syndrome</italic>
<inline-formula id="IEq2"><alternatives><tex-math id="d33e472">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\bf{s}}}\in {{\mathbb{F}}}_{2}^{| D| }$$\end{document}</tex-math><mml:math id="d33e477"><mml:mi mathvariant="bold">s</mml:mi><mml:mo>&#8712;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>&#8739;</mml:mo><mml:mi>D</mml:mi><mml:mo>&#8739;</mml:mo></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq2.gif"/></alternatives></inline-formula>, the <italic toggle="yes">decoding problem</italic> consists of finding a minimum-weight recovery <inline-formula id="IEq3"><alternatives><tex-math id="d33e496">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hat{{{\bf{e}}}}$$\end{document}</tex-math><mml:math id="d33e501"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq3.gif"/></alternatives></inline-formula> such that <inline-formula id="IEq4"><alternatives><tex-math id="d33e511">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\bf{s}}}=H\cdot \hat{{{\bf{e}}}}$$\end{document}</tex-math><mml:math id="d33e516"><mml:mi mathvariant="bold">s</mml:mi><mml:mo>=</mml:mo><mml:mi>H</mml:mi><mml:mo>&#8901;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq4.gif"/></alternatives></inline-formula>, where the vector <inline-formula id="IEq5"><alternatives><tex-math id="d33e530">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hat{{{\bf{e}}}}\in {{\mathbb{F}}}_{2}^{| F| }$$\end{document}</tex-math><mml:math id="d33e535"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>&#8712;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mo>&#8739;</mml:mo><mml:mi>F</mml:mi><mml:mo>&#8739;</mml:mo></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq5.gif"/></alternatives></inline-formula> indicates the locations in the circuit where faults have occurred.</p><p id="Par12">The <italic toggle="yes">decoding graph</italic> is a bipartite graph <inline-formula id="IEq6"><alternatives><tex-math id="d33e560">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathcal{G}}}(H)=({V}_{D}\cup {V}_{F},E)$$\end{document}</tex-math><mml:math id="d33e565"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq6.gif"/></alternatives></inline-formula> with <italic toggle="yes">detector</italic> nodes <italic toggle="yes">V</italic><sub><italic toggle="yes">D</italic></sub>, <italic toggle="yes">fault</italic> nodes <italic toggle="yes">V</italic><sub><italic toggle="yes">F</italic></sub> and edges (<italic toggle="yes">d</italic>,&#160;<italic toggle="yes">f</italic>)&#160;&#8712;&#160;<italic toggle="yes">E</italic>&#160;&#8660;&#160;<italic toggle="yes">H</italic><sub><italic toggle="yes">d</italic><italic toggle="yes">f</italic></sub>&#160;=&#160;1. <inline-formula id="IEq7"><alternatives><tex-math id="d33e630">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathcal{G}}}(H)$$\end{document}</tex-math><mml:math id="d33e635"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq7.gif"/></alternatives></inline-formula> is also known as the Tanner graph of the check matrix <italic toggle="yes">H</italic>. Since the detector check matrix is analogous to a parity check matrix of a classical linear code, we use the terms detectors and checks synonymously. Note that we implement a minimum-weight decoding strategy where the goal is to find the lowest-weight error compatible with the syndrome. This is distinct from maximum-likelihood decoding, where the goal is to determine the highest probability logical coset.</p></sec><sec id="Sec4"><title>Localized statistics decoding</title><p id="Par13">This section provides an example-guided outline of the localized statistics decoder. A more formal treatment, including pseudo-code, can be found in Methods.</p><p id="Par14"><italic toggle="yes">a. Notation</italic>. For an index set <italic toggle="yes">I</italic>&#160;=&#160;{<italic toggle="yes">i</italic><sub>1</sub>,&#160;&#8230;,&#160;<italic toggle="yes">i</italic><sub><italic toggle="yes">n</italic></sub>} and a matrix <italic toggle="yes">M</italic>&#160;=&#160;(<italic toggle="yes">m</italic><sub>1</sub>,&#160;&#8230;,&#160;<italic toggle="yes">m</italic><sub><italic toggle="yes">&#8467;</italic></sub>) with columns <italic toggle="yes">m</italic><sub><italic toggle="yes">j</italic></sub>, we write <inline-formula id="IEq8"><alternatives><tex-math id="d33e689">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${M}_{[I]}=({m}_{{i}_{1}},\ldots,{m}_{{i}_{n}})$$\end{document}</tex-math><mml:math id="d33e694"><mml:msub><mml:mrow><mml:mi>M</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#8230;</mml:mo><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq8.gif"/></alternatives></inline-formula> as the matrix containing only the columns indexed by <italic toggle="yes">I</italic>. Equivalently, for a vector <bold>v,</bold>
<bold>v</bold><sub>[<italic toggle="yes">I</italic>]</sub> is the vector containing only coordinates indexed by <italic toggle="yes">I</italic>.</p><p id="Par15"><italic toggle="yes">b. Inversion decoding</italic>. The <italic toggle="yes">localized statistics decoding</italic> (LSD) algorithm belongs to the class of reliability-guided inversion decoders, which also contains <italic toggle="yes">ordered statistics decoding</italic> (OSD)<sup><xref ref-type="bibr" rid="CR11">11</xref>,<xref ref-type="bibr" rid="CR21">21</xref>,<xref ref-type="bibr" rid="CR26">26</xref></sup>. OSD can solve the decoding problem by computing <inline-formula id="IEq9"><alternatives><tex-math id="d33e770">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[I]}={H}_{[I]}^{-1}\cdot {{\bf{s}}}$$\end{document}</tex-math><mml:math id="d33e775"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>&#8901;</mml:mo><mml:mi mathvariant="bold">s</mml:mi></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq9.gif"/></alternatives></inline-formula>. Here, <italic toggle="yes">H</italic><sub>[<italic toggle="yes">I</italic>]</sub> is an invertible matrix formed by selecting a linearly independent subset of the columns of the check matrix <italic toggle="yes">H</italic> indexed by the set of column indices <italic toggle="yes">I</italic>. The algorithm is reliability-guided in that it uses prior knowledge of the error distribution to strategically select <italic toggle="yes">I</italic> so that the solution <inline-formula id="IEq10"><alternatives><tex-math id="d33e826">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[I]}$$\end{document}</tex-math><mml:math id="d33e831"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq10.gif"/></alternatives></inline-formula> spans faults that have the highest error probability. The reliabilities can be derived, for example, from the device&#8217;s physical error model<sup><xref ref-type="bibr" rid="CR16">16</xref>,<xref ref-type="bibr" rid="CR33">33</xref>&#8211;<xref ref-type="bibr" rid="CR37">37</xref></sup> or the soft information output of a <italic toggle="yes">pre-decoder</italic> such as BP<sup><xref ref-type="bibr" rid="CR38">38</xref></sup>.</p><p id="Par16"><italic toggle="yes">c. Factorizing the decoding problem</italic>. In general, solving the system <inline-formula id="IEq11"><alternatives><tex-math id="d33e870">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[I]}={H}_{[I]}^{-1}\cdot {{\bf{s}}}$$\end{document}</tex-math><mml:math id="d33e875"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>&#8901;</mml:mo><mml:mi mathvariant="bold">s</mml:mi></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq9.gif"/></alternatives></inline-formula> involves applying Gaussian elimination to compute the inverse <inline-formula id="IEq12"><alternatives><tex-math id="d33e908">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[I]}^{-1}$$\end{document}</tex-math><mml:math id="d33e913"><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq12.gif"/></alternatives></inline-formula>, which has cubic worst-case time complexity, <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic><sup>3</sup>), in the size <italic toggle="yes">n</italic> of the check matrix <italic toggle="yes">H</italic>. The essential idea behind the LSD decoder is that, for low physical error rates, the decoding problem for QLDPC amounts to solving a sparse system of linear equations. In this setting, the inversion decoding problem can be factorized into a set of independent linear sub-systems that can be solved concurrently.</p><p id="Par17">Figure&#160;<xref rid="Fig1" ref-type="fig">1</xref> shows an example of error factorization in the Tanner graph of a 5&#160;&#215;&#160;10 surface code. The support of a fault vector <bold>e</bold> is illustrated by the circular nodes marked with an <italic toggle="yes">X</italic> and the corresponding syndrome is depicted by the square nodes filled in red. In this example, it is clear that <bold>e</bold> can be split into two connected components, <inline-formula id="IEq13"><alternatives><tex-math id="d33e956">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{e}}}}_{[{C}_{1}]}$$\end{document}</tex-math><mml:math id="d33e961"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq13.gif"/></alternatives></inline-formula> and <inline-formula id="IEq14"><alternatives><tex-math id="d33e979">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{e}}}}_{[{C}_{2}]}$$\end{document}</tex-math><mml:math id="d33e984"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq14.gif"/></alternatives></inline-formula>, that occupy separate regions of the decoding graph. We refer to each of the connected components induced by an error on the decoding graph as <italic toggle="yes">clusters</italic>. With a slight misuse of notation, we refer to clusters <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> and their associated incidence matrices <inline-formula id="IEq15"><alternatives><tex-math id="d33e1010">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1015"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> interchangeably and use &#8739;<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>&#8739; to denote the number of fault nodes (columns) in the cluster (its incidence matrix, respectively). This identification is natural as clusters are uniquely identified by their fault nodes, or equivalently, by column indices of <italic toggle="yes">H</italic>: for a set of fault nodes <italic toggle="yes">C</italic>&#160;&#8838;&#160;<italic toggle="yes">V</italic><sub><italic toggle="yes">F</italic></sub>, we consider all of the detector nodes in <italic toggle="yes">V</italic><sub><italic toggle="yes">D</italic></sub> adjacent to at least one node in <italic toggle="yes">C</italic> to be part of the cluster.<fig id="Fig1" position="float" orientation="portrait"><label>Fig. 1</label><caption><title>Illustration of the factorization of the decoding problem on a 5&#160;&#215;&#160;10 surface code patch.</title><p>Below the threshold, errors are typically sparsely distributed on the decoding graph and form small clusters with disjoint support.</p></caption><graphic id="d33e1067" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig1_HTML.jpg"/></fig></p><p id="Par18">For the example in Fig.&#160;<xref rid="Fig1" ref-type="fig">1</xref>, the two induced clusters <inline-formula id="IEq16"><alternatives><tex-math id="d33e1073">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{1}]},{H}_{[{C}_{2}]}$$\end{document}</tex-math><mml:math id="d33e1078"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq16.gif"/></alternatives></inline-formula> are entirely independent of one another. As such, it is possible to find a decoding solution by inverting each submatrix separately,<disp-formula id="Equ1"><label>1</label><alternatives><tex-math id="d33e1108">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[{C}_{1}\cup {C}_{2}\cup {C}_{\perp }]}=\left({H}_{[{C}_{1}]}^{-1}{{{\bf{s}}}}_{[{C}_{1}]},{H}_{[{C}_{2}]}^{-1}{{{\bf{s}}}}_{[{C}_{2}]},0\right),$$\end{document}</tex-math><mml:math id="d33e1114"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mo>&#8869;</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>,</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ1.gif"/></alternatives></disp-formula>where <inline-formula id="IEq17"><alternatives><tex-math id="d33e1214">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{s}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1219"><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq17.gif"/></alternatives></inline-formula> is the subset of syndrome bits in the cluster <inline-formula id="IEq18"><alternatives><tex-math id="d33e1236">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1241"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>, which we refer to as the <italic toggle="yes">cluster syndrome</italic>. The set <italic toggle="yes">C</italic><sub>&#8869;</sub> is the column index set of fault nodes that are not in any cluster.</p><p id="Par19">In general, linear systems can be factorized into <italic toggle="yes">&#957;</italic> many decoupled clusters, yielding<disp-formula id="Equ2"><label>2</label><alternatives><tex-math id="d33e1270">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[{C}_{1}\cup \cdots \cup {C}_{\nu }\cup {C}_{\perp }]}=\left({H}_{[{C}_{1}]}^{-1}{{{\bf{s}}}}_{[{C}_{1}]},\ldots,{H}_{[{C}_{\nu }]}^{-1}{{{\bf{s}}}}_{[{C}_{\nu }]},0\right).$$\end{document}</tex-math><mml:math id="d33e1276"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mo>&#8943;</mml:mo><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#957;</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mo>&#8869;</mml:mo></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mo>&#8230;</mml:mo><mml:mo>,</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#957;</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#957;</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ2.gif"/></alternatives></disp-formula>The number of clusters, <italic toggle="yes">&#957;</italic>, will depend upon <italic toggle="yes">H</italic>, the physical error rate, and the Hamming weight of <bold>s</bold>. If a factorization can be found, matrix inversion is efficient: first, the <italic toggle="yes">&#957;</italic> clusters can be solved in parallel; second, the parallel worst-case time complexity of the algorithm depends on the maximum size of a cluster <inline-formula id="IEq19"><alternatives><tex-math id="d33e1393">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\kappa={\max }_{i}\left(| {C}_{i}| \right)$$\end{document}</tex-math><mml:math id="d33e1398"><mml:mi>&#954;</mml:mi><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>max</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mfenced close=")" open="("><mml:mrow><mml:mo>&#8739;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8739;</mml:mo></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq19.gif"/></alternatives></inline-formula>, where &#8739;<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>&#8739; is the number of fault nodes in <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>. The worst-case scaling <italic toggle="yes">O</italic>(<italic toggle="yes">&#954;</italic><sup>3</sup>) contrasts with the <italic toggle="yes">O</italic>(<italic toggle="yes">n</italic><sup>3</sup>) OSD post-processing scaling, where <italic toggle="yes">n</italic>&#160;=&#160;&#8739;<italic toggle="yes">V</italic><sub><italic toggle="yes">F</italic></sub>&#8739; is the size of the matrix <italic toggle="yes">H</italic>. To enable parallel execution, we have devised a routine that we call <italic toggle="yes">on-the-fly elimination</italic> to efficiently merge clusters and compute a matrix factorization, as detailed in the Methods.</p><p id="Par20"><italic toggle="yes">d. Weighted cluster growth and the LSD validity condition</italic>. For a given syndrome, the LSD algorithm is designed to find a factorization of the decoding graph that is as close to the optimal factorization as possible. Here, we define a factorization as <italic toggle="yes">optimal</italic> if its clusters correspond exactly to the connected components induced by the error.</p><p id="Par21">The LSD decoder uses a weighted, reliability-based growth strategy to factorize the decoding graph. The algorithm begins by creating a cluster <inline-formula id="IEq20"><alternatives><tex-math id="d33e1469">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1474"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> for each flipped detector node, i.e., a separate cluster is generated for every nonzero bit in the syndrome vector <bold>s</bold>. At every growth step, each cluster <inline-formula id="IEq21"><alternatives><tex-math id="d33e1493">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1498"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> is grown by one column by adding the fault node from its neighborhood with the highest probability of being in error according to the input reliability information. This weighted growth strategy is crucial for controlling the cluster size: limiting growth to a single fault node per time step increases the likelihood that an efficient factorization is found, especially for QLDPC codes with high degrees of expansion in their decoding graphs.</p><p id="Par22">If two or more clusters collide &#8211; that is, if a check node would be contained in multiple clusters after a growth step &#8211; the LSD algorithm merges them and forms a combined cluster. We use the notation <inline-formula id="IEq22"><alternatives><tex-math id="d33e1516">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{1}\cup {C}_{2}]}$$\end{document}</tex-math><mml:math id="d33e1521"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq22.gif"/></alternatives></inline-formula> and <inline-formula id="IEq23"><alternatives><tex-math id="d33e1543">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{s}}}}_{[{C}_{1}\cup {C}_{2}]}$$\end{document}</tex-math><mml:math id="d33e1548"><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq23.gif"/></alternatives></inline-formula> to indicate the decoding matrix and the syndrome of the combined cluster.</p><p id="Par23">For each cluster <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>, the LSD algorithm iterates cluster growth until it has enough linearly independent columns to find a local solution, i.e., until <inline-formula id="IEq24"><alternatives><tex-math id="d33e1580">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{s}}}}_{[{C}_{i}]}\in {{\rm{image}}}({H}_{[{C}_{i}]})$$\end{document}</tex-math><mml:math id="d33e1585"><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>&#8712;</mml:mo><mml:mi mathvariant="normal">image</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq24.gif"/></alternatives></inline-formula>. We call such a cluster <italic toggle="yes">valid</italic>. Once all clusters are valid, the LSD algorithm computes all local solutions, <inline-formula id="IEq25"><alternatives><tex-math id="d33e1625">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{e}}}}_{[{C}_{i}]}={H}_{[{C}_{i}]}^{-1}\cdot {{{\bf{s}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1630"><mml:msub><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>&#8901;</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq25.gif"/></alternatives></inline-formula>, and combines them into a global one.</p><p id="Par24">The process of weighted-cluster growth is conceptually similar to &#8220;belief hypergraph union-find&#8221;<sup><xref ref-type="bibr" rid="CR39">39</xref></sup> and is illustrated in Fig.&#160;<xref rid="Fig2" ref-type="fig">2</xref> for the surface code. Here, two clusters are created. These are grown according to the reliability ordering of the neighboring fault nodes. In Fig.&#160;<xref rid="Fig2" ref-type="fig">2</xref>c, the two clusters merge, yielding a combined valid cluster. The combined cluster is not optimal as its associated decoding matrix has 5 columns, whereas the local solution has Hamming weight 3, indicating that the optimal cluster would have 3 columns. Nonetheless, computing a solution using the cluster matrix with 5 columns is still preferable to computing a solution using the full 41-column decoding matrix &#8211; this highlights the possible computational gain of LSD.<fig id="Fig2" position="float" orientation="portrait"><label>Fig. 2</label><caption><title>Reliability-based weighted cluster growth example for the surface code.</title><p><bold>a</bold> The syndrome of an error is indicated as red square vertices. The fault nodes are colored to visualize their error probabilities obtained from belief propagation pre-processing. <bold>b</bold> Clusters after the first two growth steps. In the guided cluster growth strategy, fault nodes are added individually to the local clusters. The order of adding the first two fault nodes to each cluster is random since both have the same probability due to the presence of degenerate errors. <bold>c</bold> After an additional growth step, the two clusters are merged and the combined cluster is valid. <bold>d</bold> Legend for the used symbols.</p></caption><graphic id="d33e1710" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig2_HTML.jpg"/></fig></p><p id="Par25"><italic toggle="yes">e</italic>. On-the-fly <italic toggle="yes">elimination and parallel implementation</italic>. To avoid the overhead incurred by checking the validity condition after each growth step &#8211; a bottleneck for other clustering decoders for QLDPC codes<sup><xref ref-type="bibr" rid="CR40">40</xref></sup> &#8211; we have developed an efficient algorithm that we call <italic toggle="yes">on-the-fly elimination</italic>. Our algorithm maintains a dedicated data structure that allows for efficient computation of a matrix factorization of each cluster when additional columns are added to the cluster, even if clusters merge &#8211; see Methods for details. Importantly, at each growth step, due to our on-the-fly technique, we only need to eliminate a single additional column vector without having to re-eliminate columns from previous growth steps.</p><p id="Par26">Crucially, on-the-fly elimination can be applied in parallel to each cluster <inline-formula id="IEq26"><alternatives><tex-math id="d33e1727">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e1732"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>. Using the on-the-fly data structure that enables clusters to be efficiently extended without having to recompute their new factorization from scratch, we propose a fully <italic toggle="yes">parallel implementation of LSD</italic> in Section&#160;<xref rid="MOESM1" ref-type="media">2</xref> of the Supplementary Material. There, we analyze parallel LSD time complexity and show that the overhead for each parallel resource is low and predominantly depends on the cluster sizes.</p><p id="Par27"><italic toggle="yes">f. Factorization in decoding graphs</italic>. A key feature of LSD is to divide the decoding problem into smaller, local sub-problems that correspond to error clusters on the decoding graph. To provide more insight, we investigate cluster formation under a specific noise model and compare these clusters obtained directly from the error to the clusters identified by LSD.</p><p id="Par28">As a timely example, we focus specifically on the cluster size statistics of the circuit-noise decoding graph of the [[144,12,12]] bivariate bicycle code<sup><xref ref-type="bibr" rid="CR41">41</xref></sup> that was recently investigated in ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup>. Figure&#160;<xref rid="Fig3" ref-type="fig">3</xref>a shows the distribution of the maximum sizes of clusters identified by BP+LSD over 10<sup>5</sup> decoding samples, see Methods for details. The figure illustrates that for low enough noise rates, the largest clusters found by LSD are small and close to the optimal sizes of clusters induced by the original error, even if only a relatively small number (30) of BP iterations is used to compute the soft information input to LSD. It is worth emphasizing that large clusters are typically formed by merging two, or more, smaller clusters identified and processed at previous iterations of the algorithm. Owing to our on-the-fly technique that processes the linear system corresponding to each of these clusters (cf. Methods), the maximum cluster size only represents a loose upper bound on the complexity of the LSD algorithm.<fig id="Fig3" position="float" orientation="portrait"><label>Fig. 3</label><caption><title>Cluster size statistics of the [[144, 12, 12]] bivariate bicycle code of ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup> under circuit-level noise with strength <italic toggle="yes">p.</italic></title><p>Markers show the mean of the distribution while shapes are violin plots of the distribution obtained from 10<sup>5</sup> samples. Yellow distributions show statistics for the optimal factorization while the blue distributions show statistics for the factorization returned by BP+LSD. We show in (<bold>a</bold>) the distribution of the maximum cluster size <italic toggle="yes">&#954;</italic> and in (<bold>b</bold>) the distribution of the cluster count, <italic toggle="yes">&#957;</italic>, for each decoding sample. Markers and distributions are slightly offset from the actual error rate to increase readability.</p></caption><graphic id="d33e1802" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig3_HTML.jpg"/></fig></p><p id="Par29">Figure&#160;<xref rid="Fig3" ref-type="fig">3</xref> b shows the distributions of the cluster count per shot, <italic toggle="yes">&#957;</italic> &#8211; that is, per shot, where the LSD data is post-selected on shots where BP does not converge &#8211; against the physical error rate <italic toggle="yes">p</italic>. The number of clusters <italic toggle="yes">&#957;</italic> corresponds to the number of terms in the factorization of the decoding problem and thus indicates the degree to which the decoding can be parallelized, as disjoint factors can be solved concurrently. At practically relevant error rates below the (pseudo) threshold, e.g., <italic toggle="yes">p</italic> &#8804;0.1%, we observe on average 10 independent clusters. This implies that the LSD algorithm benefits from parallel resources throughout its execution.</p><p id="Par30">We explore bounds on the sizes of clusters induced by errors on QLDPC code graphs in Section&#160;<xref rid="MOESM1" ref-type="media">1</xref> of the Supplementary Material. Our findings suggest that detector matrices generally exhibit a strong suitability for factorization, a feature that the LSD algorithm is designed to capitalize on.</p><p id="Par31"><italic toggle="yes">g. Higher-order reprocessing</italic>. Higher-order reprocessing in OSD is a systematic approach designed to increase the decoder&#8217;s accuracy. The zero-order solution <inline-formula id="IEq27"><alternatives><tex-math id="d33e1829">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[I]}={H}_{[I]}^{-1}\cdot {{\bf{s}}}$$\end{document}</tex-math><mml:math id="d33e1834"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:mo>&#8901;</mml:mo><mml:mi mathvariant="bold">s</mml:mi></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq9.gif"/></alternatives></inline-formula> of the decoder cannot be made lower weight if the set of column indices <italic toggle="yes">I</italic> specifying the invertible submatrix <italic toggle="yes">H</italic><sub>[<italic toggle="yes">I</italic>]</sub> matches the &#8739;<italic toggle="yes">I</italic>&#8739; most likely fault locations identified from the soft information vector <bold>&#955;</bold>. However, if there are linear dependencies within the columns formed by the &#8739;<italic toggle="yes">I</italic>&#8739; most likely fault locations, the solution <inline-formula id="IEq28"><alternatives><tex-math id="d33e1888">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hat{{{\bf{e}}}}$$\end{document}</tex-math><mml:math id="d33e1893"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq3.gif"/></alternatives></inline-formula> may not be optimal. In those cases, some fault locations in <inline-formula id="IEq29"><alternatives><tex-math id="d33e1902">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\overline{I}$$\end{document}</tex-math><mml:math id="d33e1907"><mml:mover accent="true"><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo accent="true">&#175;</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq29.gif"/></alternatives></inline-formula> (the complement of <italic toggle="yes">I</italic>) might have higher error probabilities. To find the optimal solution, one can systematically search all valid fault configurations in <inline-formula id="IEq30"><alternatives><tex-math id="d33e1918">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\overline{I}$$\end{document}</tex-math><mml:math id="d33e1923"><mml:mover accent="true"><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo accent="true">&#175;</mml:mo></mml:mover></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq29.gif"/></alternatives></inline-formula> that potentially provide a more likely estimate <inline-formula id="IEq31"><alternatives><tex-math id="d33e1932">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\hat{{{\bf{e}}}}{\prime}$$\end{document}</tex-math><mml:math id="d33e1937"><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover><mml:mo>&#8242;</mml:mo></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq31.gif"/></alternatives></inline-formula>. This search space, however, is exponentially large in <inline-formula id="IEq32"><alternatives><tex-math id="d33e1947">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$| \overline{I}|$$\end{document}</tex-math><mml:math id="d33e1952"><mml:mo>&#8739;</mml:mo><mml:mover accent="true"><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo accent="true">&#175;</mml:mo></mml:mover><mml:mo>&#8739;</mml:mo></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq32.gif"/></alternatives></inline-formula>. Thus, in practice, only configurations with a Hamming weight up to <italic toggle="yes">w</italic> are considered, known as <italic toggle="yes">order-w</italic> reprocessing. See refs. <sup><xref ref-type="bibr" rid="CR11">11</xref>,<xref ref-type="bibr" rid="CR21">21</xref>,<xref ref-type="bibr" rid="CR25">25</xref>,<xref ref-type="bibr" rid="CR26">26</xref></sup> for a more technical discussion.</p><p id="Par32">In BP+OSD-<italic toggle="yes">w</italic> applied to <italic toggle="yes">H</italic>, order-<italic toggle="yes">w</italic> reprocessing is frequently the computational bottleneck because of the extensive search space and the necessary matrix-vector multiplications involving <italic toggle="yes">H</italic><sub>[<italic toggle="yes">I</italic>]</sub> and <inline-formula id="IEq33"><alternatives><tex-math id="d33e2000">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[\overline{I}]}$$\end{document}</tex-math><mml:math id="d33e2005"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi>I</mml:mi></mml:mrow><mml:mo accent="true">&#175;</mml:mo></mml:mover></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq33.gif"/></alternatives></inline-formula> to validate fault configurations. Inspired by higher-order OSD, we propose a higher-order reprocessing method for LSD, which we refer to as LSD&#160;&#8722;&#160;<italic toggle="yes">&#956;</italic>. We find that when higher-order reprocessing is applied to LSD, it is sufficient to process clusters locally. This offers three key advantages: parallel reprocessing, a reduced higher-order search space, and smaller matrix-vector multiplications. Furthermore, our numerical simulations indicate that decoding improvements of local BP+LSD&#160;&#8722;&#160;<italic toggle="yes">&#956;</italic> are on par with those of global BP+OSD&#160;&#8722;&#160;<italic toggle="yes">w</italic>. For more details on higher-order reprocessing with LSD and additional numerical results, see Section&#160;<xref rid="MOESM1" ref-type="media">4</xref> of the Supplementary Material.</p></sec><sec id="Sec5"><title>Numerical results</title><p id="Par33">For the numerical simulations in this work, we implement serial LSD, where the reliability information is provided by a BP pre-decoder. The BP decoder is run in the first instance, and if no solution is found, LSD is invoked as a post-processor. Our serial implementation of this BP+LSD decoder is written in C++ with a python interface and is available open-source as part of the LDPC package<sup><xref ref-type="bibr" rid="CR42">42</xref></sup>.</p><p id="Par34">Our main numerical finding is that BP+LSD can decode QLDPC codes with performance on par with BP+OSD. We include the results of extensive simulations in which BP+LSD is used to decode a circuit-level depolarizing noise model for surface codes, hypergraph product (HGP) codes<sup><xref ref-type="bibr" rid="CR43">43</xref></sup>, and bivariate bicycle codes<sup><xref ref-type="bibr" rid="CR12">12</xref>,<xref ref-type="bibr" rid="CR41">41</xref></sup>.</p><p id="Par35">In BP+OSD decoding, it is common to run many BP iterations to maximize the chance of convergence and reduce the reliance on OSD post-processing. A strength of the BP+LSD decoder is that LSD is less costly than OSD and, therefore, applying the LSD routine after running BP introduces comparatively small overall computational overhead. As a result, the number of BP iterations in BP+LSD can be considerably reduced since LSD requires only a few BP iterations to obtain meaningful soft information values. This is in stark contrast to BP+OSD, where it is often more efficient to run many BP iterations rather than deferring to costly OSD. In this work, we use a fixed number of 30 BP iterations for all decoding simulations with BP+LSD. For context, this is a significant reduction compared to the decoding simulations of ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup> where BP+OSD was run with 10<sup>4</sup> BP iterations.</p><p id="Par36"><italic toggle="yes">a. Surface codes</italic>. We compare the threshold of BP+LSD with various state-of-the-art decoders that are similarly guided by the soft information output of a BP decoder. In particular, we compare the proposed BP+LSD algorithm with BP+OSD (order 0)<sup><xref ref-type="bibr" rid="CR21">21</xref></sup>, as well as our implementation of a BP plus union-find (BP+UF) decoder<sup><xref ref-type="bibr" rid="CR44">44</xref></sup> that is tailored to matchable codes. The results are shown in Fig.&#160;<xref rid="Fig4" ref-type="fig">4</xref>. The main result is that both BP+OSD and BP+LSD achieve a similar threshold close to a physical error rate of <italic toggle="yes">p</italic>&#160;&#8776;&#160;0.7%, and similar logical error rates, see panels (a) and (c), respectively. In particular, in the relevant sub-threshold regime, where BP+LSD can be run in parallel, its logical decoding performance matches BP+OSD. Note that this is the desired outcome and demonstrates that our algorithm achieves (close to) identical performance with BP+OSD while maintaining locality. Our implementation of the BP+UF decoder of ref. <sup><xref ref-type="bibr" rid="CR38">38</xref></sup>, see panel (b), performs slightly worse, achieving a threshold closer to <italic toggle="yes">p</italic>&#160;&#8776;&#160;0.6% and higher logical error rates, potentially due to a non-optimized implementation.<fig id="Fig4" position="float" orientation="portrait"><label>Fig. 4</label><caption><title>Comparison of various decoders guided by belief propagation for decoding rotated surface codes of distance <italic toggle="yes">d</italic> subject to circuit-level depolarizing noise parameterized by a single parameter, called the <italic toggle="yes">physical error rate</italic><italic toggle="yes">p</italic>, see Section IV C for details.</title><p>We use Stim to perform a surface_code:rotated_memory_z experiment for <italic toggle="yes">d</italic> syndrome extraction cycles with single and two-qubit error probabilities <italic toggle="yes">p</italic>. <bold>a</bold> The performance of BP+OSD-0 that matches the performance of the proposed decoder. <bold>b</bold> The performance of a BeliefFind decoder that shares a cluster growth strategy with the proposed decoder. <bold>c</bold> Performance of the proposed BP+LSD decoder. The shading indicates hypotheses whose likelihoods are within a factor of 1000 of the maximum likelihood estimate, similar to a confidence interval.</p></caption><graphic id="d33e2134" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig4_HTML.jpg"/></fig></p><p id="Par37"><italic toggle="yes">b. Random (3,4)-regular hypergraph product codes</italic>.&#160;Fig.&#160;<xref rid="Fig5" ref-type="fig">5</xref> shows the results of decoding simulations for the family of hypergraph product codes<sup><xref ref-type="bibr" rid="CR43">43</xref></sup> that were recently studied in ref. <sup><xref ref-type="bibr" rid="CR13">13</xref></sup>. The plot shows the logical error rate per syndrome cycle <inline-formula id="IEq34"><alternatives><tex-math id="d33e2150">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${p}_{L}=1-{(1-{P}_{L}({N}_{c}))}^{1/{N}_{c}}$$\end{document}</tex-math><mml:math id="d33e2155"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:mn>1</mml:mn><mml:mo>&#8722;</mml:mo><mml:msup><mml:mrow><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mn>1</mml:mn><mml:mo>&#8722;</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>L</mml:mi></mml:mrow></mml:msub><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow><mml:mrow><mml:mn>1</mml:mn><mml:mo>/</mml:mo><mml:msub><mml:mrow><mml:mi>N</mml:mi></mml:mrow><mml:mrow><mml:mi>c</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq34.gif"/></alternatives></inline-formula>, where <italic toggle="yes">N</italic><sub><italic toggle="yes">c</italic></sub> is the number of syndrome cycles and <italic toggle="yes">P</italic><sub><italic toggle="yes">L</italic></sub>(<italic toggle="yes">N</italic><sub><italic toggle="yes">c</italic></sub>) the logical error rate after <italic toggle="yes">N</italic><sub><italic toggle="yes">c</italic></sub> rounds. Under the assumption of an identical, independent circuit-level noise model, BP+LSD significantly outperforms the BP plus small set-flip (BP+SSF) decoder investigated in ref. <sup><xref ref-type="bibr" rid="CR45">45</xref></sup>. For example, for the [[625, 25]] code instance at <italic toggle="yes">p</italic>&#160;&#8776;&#160;0.1%, BP+LSD improves logical error suppression by almost two orders of magnitude compared to BP+SSF.<fig id="Fig5" position="float" orientation="portrait"><label>Fig. 5</label><caption><title>Below threshold logical error rate <italic toggle="yes">p</italic><sub><italic toggle="yes">L</italic></sub> of a family of [[25<italic toggle="yes">s</italic><sup>2</sup>,&#160;<italic toggle="yes">s</italic><sup>2</sup>]] constant-rate hypergraph product codes decoded with the BP+LSD decoder.</title><p>We simulate <italic toggle="yes">N</italic><sub><italic toggle="yes">c</italic></sub> = 12 rounds of syndrome extraction cycles under circuit-level noise with physical error rate <italic toggle="yes">p</italic> and apply a (3,&#160;1)-overlapping window technique to enable fast and accurate single-shot decoding, see Methods for details. The shading indicates hypotheses whose likelihoods are within a factor of 1000 of the maximum likelihood estimate, similar to a confidence interval. Dashed lines are an exponential fit with a linear exponent to the numerically observed error rates.</p></caption><graphic id="d33e2261" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig5_HTML.jpg"/></fig></p><p id="Par38"><italic toggle="yes">c. Bivariate bicycle codes</italic>. Here, we present decoding simulation results of the <italic toggle="yes">bivariate bicycle</italic> (BB) codes. These codes are part of the family of hyperbicycle codes originally introduced in ref. <sup><xref ref-type="bibr" rid="CR41">41</xref></sup>, and more recently investigated at the circuit level in ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup>. In Fig.&#160;<xref rid="Fig6" ref-type="fig">6</xref>, we show the logical error <italic toggle="yes">Z</italic> rate per syndrome cycle, <inline-formula id="IEq35"><alternatives><tex-math id="d33e2284">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${p}_{{L}_{Z}}$$\end{document}</tex-math><mml:math id="d33e2289"><mml:msub><mml:mrow><mml:mi>p</mml:mi></mml:mrow><mml:mrow><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>Z</mml:mi></mml:mrow></mml:msub></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq35.gif"/></alternatives></inline-formula>. We find that with BP+LSD we obtain comparable decoding performance to the results presented in ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup> where simulations were run using BP+OSD-CS-7 (where BP+OSD-CS-7 refers to the &#8220;combination sweep&#8221; strategy for BP+OSD higher-order processing with order <italic toggle="yes">w</italic>&#160;=&#160;7, see ref. <sup><xref ref-type="bibr" rid="CR21">21</xref></sup> for more details).<fig id="Fig6" position="float" orientation="portrait"><label>Fig. 6</label><caption><title>Logical error rate per syndrome cycle <italic toggle="yes">p</italic><sub><italic toggle="yes">L</italic></sub> for various bivariate bicycle codes under a circuit-level noise model.</title><p>For each code, <italic toggle="yes">d</italic> rounds of syndrome extraction are simulated and the full syndrome history is decoded using BP+LSD. The shading highlights the region of estimated probabilities where the likelihood ratio is within a factor of 1000, similar to a confidence interval. Dashed lines are an exponential fit with a quadratic exponent to the numerically observed error rates.</p></caption><graphic id="d33e2330" position="float" orientation="portrait" xlink:href="41467_2025_63214_Fig6_HTML.jpg"/></fig></p><p id="Par39"><italic toggle="yes">d. Runtime statistics</italic>. To estimate the time overhead of the proposed decoder in numerical simulation scenarios and to compare it with a state-of-the-art implementation of BP+OSD, we present preliminary timing results for our prototypical open-source implementation of LSD in Section&#160;<xref rid="MOESM1" ref-type="media">3.4</xref> of the Supplementary Material. We note that for a more complete assessment of performance, it will be necessary to benchmark a fully parallel implementation of the algorithm, designed for specialized hardware such as GPUs or FPGAs. We leave this as a topic for future work.</p></sec></sec><sec id="Sec6" sec-type="discussion"><title>Discussion</title><p id="Par40">When considering large QLDPC codes, current state-of-the-art decoders such as BP+OSD hit fundamental limitations due to the size of the resulting decoding graphs. This limitation constitutes a severe bottleneck in the realization of protocols based on QLDPC codes. In this work, we address this challenge through the introduction of the LSD decoder as a parallel algorithm whose runtime depends predominantly on the physical error rate of the system. Our algorithm uses a reliability-based growth procedure to construct clusters on the decoding graph in a parallel fashion. Using a novel routine that computes the PLU decomposition<sup><xref ref-type="bibr" rid="CR46">46</xref></sup> of the clusters&#8217; sub-matrices on-the-fly, we can merge clusters efficiently and compute local decoding solutions in a parallel fashion. Our main numerical findings are that the proposed decoder performs on par with current state-of-the-art decoding methods in terms of logical decoding performance.</p><p id="Par41">A practical implementation of the algorithm has to be runtime efficient enough to overcome the so-called backlog problem<sup><xref ref-type="bibr" rid="CR47">47</xref></sup>, where syndrome data accumulates since the decoder is not fast enough. While we have implemented an overlapping window decoding technique for our algorithm, it might be interesting to further investigate the performance of LSD under parallel window decoding<sup><xref ref-type="bibr" rid="CR20">20</xref></sup>, where the overlapping decoding window is subdivided to allow for further parallelization of syndrome data decoding.</p><p id="Par42">To decode syndrome data from quantum computing experiments in real-time, it will be necessary to use specialized hardware such as <italic toggle="yes">field programmable gate arrays</italic> (FPGAs) or <italic toggle="yes">application-specific integrated circuits</italic> (ASICs), as recently demonstrated for variants of the union-find surface code decoder<sup><xref ref-type="bibr" rid="CR48">48</xref>&#8211;<xref ref-type="bibr" rid="CR50">50</xref></sup> or possibly cellular automaton based approaches<sup><xref ref-type="bibr" rid="CR51">51</xref></sup>. A promising avenue for future research is to explore the implementation of an LSD decoder on such hardware to assess its performance with real-time syndrome measurements.</p><p id="Par43">Concerning alternative noise models, erasure-biased systems have recently been widely investigated<sup><xref ref-type="bibr" rid="CR52">52</xref>&#8211;<xref ref-type="bibr" rid="CR55">55</xref></sup>. We conjecture that LSD can readily be generalized to erasure decoding, either by adapting the cluster initialization or by considering a re-weighting procedure of the input reliabilities. We leave a numerical analysis as a topic for future work.</p><p id="Par44">Finally, it would be interesting to investigate the use of maximum-likelihood decoding at the cluster level as recently explored in ref. <sup><xref ref-type="bibr" rid="CR56">56</xref></sup> as part of the BP plus ambiguity clustering (BP+AC) decoder. Specifically, such a method could improve the efficiency of the LSD&#160;&#8722;&#160;<italic toggle="yes">&#956;</italic> higher-order reprocessing routines we explored. Similarly, the BP+AC decoder could benefit from the results of this paper: our parallel LSD cluster growth strategy, combined with on-the-fly elimination, provides an efficient strategy for finding the BP+AC block structure using parallel hardware.</p></sec><sec id="Sec7"><title>Methods</title><sec id="Sec8"><title>LSD algorithm</title><p id="Par45">In this section, we provide a detailed description of the LSD algorithm and its underlying data structure designed for efficient cluster growth, merging, validation, and ultimately local inversion decoding. We start with some foundational definitions.</p><sec id="FPar1"><title><italic toggle="yes">Definition</italic> 1.1</title><p id="Par46">(Clusters). Let <inline-formula id="IEq36"><alternatives><tex-math id="d33e2406">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathcal{G}}}(H)=({V}_{D}\cup {V}_{F},E)$$\end{document}</tex-math><mml:math id="d33e2411"><mml:mi class="MJX-tex-caligraphic" mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq6.gif"/></alternatives></inline-formula> be the decoding graph of a QLDPC code with detector nodes <italic toggle="yes">V</italic><sub><italic toggle="yes">D</italic></sub> and fault nodes <italic toggle="yes">V</italic><sub><italic toggle="yes">F</italic></sub>. There exists an edge (<italic toggle="yes">d</italic>,&#160;<italic toggle="yes">f</italic>)&#160;&#8712;&#160;<italic toggle="yes">E</italic>&#160;&#8660;&#160;<italic toggle="yes">H</italic><sub><italic toggle="yes">d</italic><italic toggle="yes">f</italic></sub>&#160;=&#160;1. A <italic toggle="yes">cluster</italic><inline-formula id="IEq37"><alternatives><tex-math id="d33e2471">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$C=({V}_{D}^{C}\cup {V}_{F}^{C},{E}^{C})\subseteq {{\mathcal{G}}}(H)$$\end{document}</tex-math><mml:math id="d33e2476"><mml:mi>C</mml:mi><mml:mo>=</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#8746;</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup><mml:mo>,</mml:mo><mml:msup><mml:mrow><mml:mi>E</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8838;</mml:mo><mml:mi class="MJX-tex-caligraphic" mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq37.gif"/></alternatives></inline-formula> is a connected component of the decoding graph.</p></sec><sec id="FPar2"><title><italic toggle="yes">Definition</italic> 1.2</title><p id="Par47">(Cluster sub-matrix). Given a set of column indices <italic toggle="yes">C</italic> of a cluster, the sub-matrix <italic toggle="yes">H</italic><sub>[<italic toggle="yes">C</italic>]</sub> of the check matrix <italic toggle="yes">H</italic> is called the <italic toggle="yes">cluster sub-matrix</italic>. The <italic toggle="yes">local syndrome</italic><bold>s</bold><sub>[<italic toggle="yes">C</italic>]</sub> of a cluster is the support vector of detector nodes in the cluster. A cluster is <italic toggle="yes">valid</italic> if <bold>s</bold><sub>[<italic toggle="yes">C</italic>]</sub>&#160;&#8712;&#160;IMAGE(<italic toggle="yes">H</italic><sub>[<italic toggle="yes">C</italic>]</sub>). Note that a cluster is uniquely identified by the columns of its sub-matrix <italic toggle="yes">H</italic><sub>[<italic toggle="yes">C</italic>]</sub>, hence we use <italic toggle="yes">H</italic><sub>[<italic toggle="yes">C</italic>]</sub> to denote both the cluster and its sub-matrix.</p></sec><sec id="FPar3"><title><italic toggle="yes">Definition</italic> 1.3</title><p id="Par48">(Cluster-boundary and candidate fault nodes) The set of <italic toggle="yes">boundary detector</italic> nodes <inline-formula id="IEq38"><alternatives><tex-math id="d33e2595">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\beta (C)\subseteq {V}_{D}^{C}$$\end{document}</tex-math><mml:math id="d33e2600"><mml:mi>&#946;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8838;</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq38.gif"/></alternatives></inline-formula> of a cluster <italic toggle="yes">C</italic> is the set<disp-formula id="Equ3"><label>3</label><alternatives><tex-math id="d33e2620">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\beta (C)=\{d\in {V}_{D}^{C}| \Gamma (d) \nsubseteq {\Gamma}_{F}^{C}\}$$\end{document}</tex-math><mml:math id="d33e2626"><mml:mi>&#946;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>d</mml:mi><mml:mo>&#8712;</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>D</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup><mml:mo>&#8739;</mml:mo><mml:mi mathvariant="normal">&#915;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>d</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8840;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="normal">&#915;</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ3.gif"/></alternatives></disp-formula>of all detector nodes in <italic toggle="yes">C</italic> that are connected to at least one fault node not in <italic toggle="yes">C</italic>, where <italic toggle="yes">&#923;</italic>(<italic toggle="yes">v</italic>) is the neighborhood of the vertex v, i.e., <inline-formula id="IEq39"><alternatives><tex-math id="d33e2679">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Lambda (v)=\{u\in {{\mathcal{G}}}(H)| (v,u)\in E\}$$\end{document}</tex-math><mml:math id="d33e2684"><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:mi>u</mml:mi><mml:mo>&#8712;</mml:mo><mml:mi class="MJX-tex-caligraphic" mathvariant="script">G</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8739;</mml:mo><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>v</mml:mi><mml:mo>,</mml:mo><mml:mi>u</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8712;</mml:mo><mml:mi>E</mml:mi></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq39.gif"/></alternatives></inline-formula>. We define <italic toggle="yes">candidate fault nodes</italic><inline-formula id="IEq40"><alternatives><tex-math id="d33e2720">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Lambda (C)\subseteq {V}_{F}\setminus {V}_{F}^{C}$$\end{document}</tex-math><mml:math id="d33e2725"><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8838;</mml:mo><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>\</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq40.gif"/></alternatives></inline-formula> as the set of fault nodes not in <italic toggle="yes">C</italic> and connected to at least one boundary detector node in <italic toggle="yes">&#946;</italic>(<italic toggle="yes">C</italic>)<disp-formula id="Equ4"><label>4</label><alternatives><tex-math id="d33e2759">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\Lambda (C)=\Lambda \left(\beta (C)\right)\cap \left({V}_{F}\setminus {V}_{F}^{C}\right).$$\end{document}</tex-math><mml:math id="d33e2765"><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>=</mml:mo><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mfenced close=")" open="("><mml:mrow><mml:mi>&#946;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:mrow></mml:mfenced><mml:mo>&#8745;</mml:mo><mml:mfenced close=")" open="("><mml:mrow><mml:msub><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>\</mml:mo><mml:msubsup><mml:mrow><mml:mi>V</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow><mml:mrow><mml:mi>C</mml:mi></mml:mrow></mml:msubsup></mml:mrow></mml:mfenced><mml:mo>.</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ4.gif"/></alternatives></disp-formula></p></sec><sec id="FPar4"><title><italic toggle="yes">Definition</italic> 1.4</title><p id="Par49">(Cluster collisions) Two or more clusters {<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>} <italic toggle="yes">collide</italic> due to a set of fault nodes <italic toggle="yes">&#916;</italic><sub><italic toggle="yes">F</italic></sub> if<disp-formula id="Equ5"><label>5</label><alternatives><tex-math id="d33e2824">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\Delta }_{F}\subseteq {\bigcup }_{i}\Lambda ({C}_{i})\,\,{\mbox{and}}\,{\bigcap }_{i}\beta ({C}_{i})\cap \Lambda ({\Delta }_{F})\ne {{\emptyset}}.$$\end{document}</tex-math><mml:math id="d33e2830"><mml:msub><mml:mrow><mml:mi mathvariant="normal">&#916;</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub><mml:mo>&#8838;</mml:mo><mml:msub><mml:mrow><mml:mo mathsize="big">&#8899;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mspace width="0.25em"/><mml:mspace width="0.25em"/><mml:mstyle><mml:mtext>and</mml:mtext></mml:mstyle><mml:mspace width="0.25em"/><mml:msub><mml:mrow><mml:mo mathsize="big">&#8898;</mml:mo></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mi>&#946;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8745;</mml:mo><mml:mi mathvariant="normal">&#923;</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi mathvariant="normal">&#916;</mml:mi></mml:mrow><mml:mrow><mml:mi>F</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>&#8800;</mml:mo><mml:mi mathvariant="normal">&#8709;</mml:mi><mml:mo>.</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ5.gif"/></alternatives></disp-formula></p><p>The LSD algorithm takes as input the matrix <inline-formula id="IEq41"><alternatives><tex-math id="d33e2897">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$H\in {{\mathbb{F}}}_{2}^{m\times n}$$\end{document}</tex-math><mml:math id="d33e2902"><mml:mi>H</mml:mi><mml:mo>&#8712;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi><mml:mo>&#215;</mml:mo><mml:mi>n</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq41.gif"/></alternatives></inline-formula>, where <italic toggle="yes">m</italic>&#160;=&#160;&#8739;<italic toggle="yes">V</italic><sub><italic toggle="yes">D</italic></sub>&#8739;,&#160;<italic toggle="yes">n</italic>&#160;=&#160;&#8739;<italic toggle="yes">V</italic><sub><italic toggle="yes">F</italic></sub>&#8739;, a syndrome <inline-formula id="IEq42"><alternatives><tex-math id="d33e2936">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\bf{s}}}\in {{\mathbb{F}}}_{2}^{m}$$\end{document}</tex-math><mml:math id="d33e2941"><mml:mi mathvariant="bold">s</mml:mi><mml:mo>&#8712;</mml:mo><mml:msubsup><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq42.gif"/></alternatives></inline-formula>, and a reliability vector that contains the soft information <inline-formula id="IEq43"><alternatives><tex-math id="d33e2955">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathbf{\lambda }}}\in {{\mathbb{R}}}^{n}$$\end{document}</tex-math><mml:math id="d33e2960"><mml:mi mathvariant="bold">&#955;</mml:mi><mml:mo>&#8712;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq43.gif"/></alternatives></inline-formula>. In the following, we will assume that <bold>&#955;</bold> takes the form of <italic toggle="yes">log-likelihood-ratios</italic> (LLRs) such that the lower the LLR, the higher the probability that the corresponding fault belongs to the error. For instance, this is the form of soft information that is returned by the BP decoder.</p><p>A sequential version of the algorithm is outlined below and detailed in the pseudo-code in Box <xref rid="Sec9" ref-type="sec">1</xref>. A parallel version of the LSD algorithm is presented in Section&#160;<xref rid="MOESM1" ref-type="media">2</xref> of the Supplementary Material<list list-type="order"><list-item><p id="Par52">A cluster is created for each flipped detector node <italic toggle="yes">d</italic><sub><italic toggle="yes">i</italic></sub> where <bold>s</bold><sub><italic toggle="yes">i</italic></sub>&#160;=&#160;1. This cluster is represented by its corresponding sub-matrix <inline-formula id="IEq44"><alternatives><tex-math id="d33e3004">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3009"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>. Initially, each cluster is added to a list of invalid clusters.</p></list-item><list-item><p id="Par53">Every cluster is grown by a single node <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub> drawn from the list of candidate nodes <italic toggle="yes">&#923;</italic>(<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>). For the first growth step after cluster initialization, we define <italic toggle="yes">&#923;</italic>(<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>)&#160;=&#160;<italic toggle="yes">&#923;</italic>({<italic toggle="yes">s</italic><sub><italic toggle="yes">i</italic></sub>}) &#8211; see Definition IV.3. The chosen growth node <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub>&#160;&#8712;&#160;<italic toggle="yes">&#923;</italic>(<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>) in each step is the fault node with the highest probability of being in error. That is, <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub> has the lowest value among the LLRs for the candidate fault nodes <italic toggle="yes">&#955;</italic><sub><italic toggle="yes">j</italic></sub>&#160;&lt;&#160;<italic toggle="yes">&#955;</italic><sub><italic toggle="yes">j</italic>+1</sub>&#160;&lt;&#160;&#8943;&#160;&lt;&#160;<italic toggle="yes">&#955;</italic><sub><italic toggle="yes">&#8467;</italic></sub>,&#160;<italic toggle="yes">&#8467;</italic>&#160;=&#160;&#8739;<italic toggle="yes">&#923;</italic>(<italic toggle="yes">C</italic>)&#8739;. Hence, the growth step involves adding one new column to the cluster matrix <inline-formula id="IEq45"><alternatives><tex-math id="d33e3116">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3121"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>.</p></list-item><list-item><p id="Par54">During growth, the algorithm detects collisions between clusters due to the selected fault nodes. Clusters that collide are merged.</p></list-item><list-item><p id="Par55">The Gaussian elimination row operations performed on previous columns are performed on the new column together with the row operations needed to eliminate the newly added columns of <inline-formula id="IEq46"><alternatives><tex-math id="d33e3147">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3152"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>. In addition, every row operation applied to <inline-formula id="IEq47"><alternatives><tex-math id="d33e3168">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3173"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> is also applied to the local syndrome <inline-formula id="IEq48"><alternatives><tex-math id="d33e3189">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{s}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3194"><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq17.gif"/></alternatives></inline-formula>. This allows the algorithm to efficiently track when the cluster becomes valid. Explicitly, the cluster is valid when the syndrome becomes linearly dependent on the cluster decoding matrix i.e., when <inline-formula id="IEq49"><alternatives><tex-math id="d33e3211">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{s}}}}_{[{C}_{i}]}\in \,{{\rm{image}}}({H}_{[{C}_{i}]})$$\end{document}</tex-math><mml:math id="d33e3216"><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>&#8712;</mml:mo><mml:mspace width="0.25em"/><mml:mi mathvariant="normal">image</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq49.gif"/></alternatives></inline-formula>. In addition to cluster validation, the Gaussian elimination at each step enables an on-the-fly computation of the PLU factorization of the local cluster. We refer the reader to subsection &#8220;On-the-fly elimination&#8221; for an outline of our method.</p></list-item><list-item><p id="Par56">The valid clusters are removed from the invalid cluster list, and the algorithm continues iteratively until the invalid cluster list is empty.</p></list-item><list-item><p id="Par57">Once all clusters are valid, the local solutions <inline-formula id="IEq50"><alternatives><tex-math id="d33e3264">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3269"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq50.gif"/></alternatives></inline-formula> such that <inline-formula id="IEq51"><alternatives><tex-math id="d33e3290">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}\cdot {\hat{{{\bf{e}}}}}_{[{C}_{i}]}={{{\bf{s}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3295"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>&#8901;</mml:mo><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq51.gif"/></alternatives></inline-formula> can be computed via the PLU decomposition of each cluster matrix <inline-formula id="IEq52"><alternatives><tex-math id="d33e3345">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3350"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> that has been computed on-the-fly during cluster growth. The output of the LSD algorithm is the union of all the local decoding vectors <inline-formula id="IEq53"><alternatives><tex-math id="d33e3366">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${\hat{{{\bf{e}}}}}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3371"><mml:msub><mml:mrow><mml:mover accent="true"><mml:mrow><mml:mi mathvariant="bold">e</mml:mi></mml:mrow><mml:mrow><mml:mo>^</mml:mo></mml:mrow></mml:mover></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq50.gif"/></alternatives></inline-formula>.</p></list-item></list></p></sec></sec><sec id="Sec9"><boxed-text position="float" orientation="portrait"><label>Box 1 Localized statistics decoding (LSD) &#8211; serial algorithm</label><p id="Par58">
<inline-graphic id="d33e3397" xlink:href="41467_2025_63214_Figa_HTML.gif"/>
</p></boxed-text></sec><sec id="Sec10"><title>On-the-fly elimination</title><p id="Par59">A common method for solving linear systems of equations is to use a matrix factorization technique. A foundational theorem in linear algebra states that every invertible matrix <italic toggle="yes">A</italic> factorizes as <italic toggle="yes">A</italic>&#160;=&#160;<italic toggle="yes">P</italic><italic toggle="yes">L</italic><italic toggle="yes">U</italic>, that is, there exist matrices <italic toggle="yes">P</italic>,&#160;<italic toggle="yes">L</italic>,&#160;<italic toggle="yes">U</italic> such that<disp-formula id="Equ6"><label>6</label><alternatives><tex-math id="d33e3426">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$A=PLU,$$\end{document}</tex-math><mml:math id="d33e3432"><mml:mi>A</mml:mi><mml:mo>=</mml:mo><mml:mi>P</mml:mi><mml:mi>L</mml:mi><mml:mi>U</mml:mi><mml:mo>,</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ6.gif"/></alternatives></disp-formula>where <italic toggle="yes">P</italic> is a permutation matrix, <italic toggle="yes">U</italic> is upper triangular, and <italic toggle="yes">L</italic> is lower triangular with 1 entries on the diagonal. Once in PLU form, a solution <italic toggle="yes">x</italic> for the system <italic toggle="yes">A</italic>&#160;&#8901;&#160;<italic toggle="yes">x</italic>&#160;=&#160;<italic toggle="yes">y</italic> can be efficiently computed using the forward and back substitution procedure<sup><xref ref-type="bibr" rid="CR46">46</xref></sup>. The computational bottleneck of this method to solve linear systems stems from the Gaussian elimination procedure required to transform <italic toggle="yes">A</italic> into PLU form.</p><p id="Par60">Here, we present a novel algorithm called <italic toggle="yes">on-the-fly elimination</italic> to efficiently compute the PLU factorization over <inline-formula id="IEq54"><alternatives><tex-math id="d33e3475">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathbb{F}}}_{2}$$\end{document}</tex-math><mml:math id="d33e3480"><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq54.gif"/></alternatives></inline-formula>. Note that the algorithm can in principle be generalized to matrices over any field. However, in the context of coding theory, <inline-formula id="IEq55"><alternatives><tex-math id="d33e3489">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathbb{F}}}_{2}$$\end{document}</tex-math><mml:math id="d33e3494"><mml:msub><mml:mrow><mml:mi mathvariant="double-struck">F</mml:mi></mml:mrow><mml:mrow><mml:mn>2</mml:mn></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq54.gif"/></alternatives></inline-formula> is most relevant and we restrict the discussion to this case.</p><p id="Par61">The main idea of the on-the-fly elimination is that row operations can be applied in a column-by-column fashion. If the operations that have been applied to each column of the matrix are stored, they can be applied to a newly added column such that only this column needs to be eliminated as all other columns are already in reduced form. This highlights the nice interplay between cluster growth (i.e., appending columns) and the on-the-fly elimination for PLU factorization of the cluster matrix.</p><p id="Par62">To grow and merge clusters, multiple smaller steps are necessary. As detailed above, these steps include identifying fault nodes/column indices of the decoding matrix <italic toggle="yes">H</italic> by which the invalid clusters will grow and determining whether an added fault node will lead to two or more clusters merging into a single one &#8211; see Definition IV.4. For simplicity, we first describe the case of sequential cluster growth. Our on-the-fly procedure can analogously be applied in a parallel implementation, see Section&#160;<xref rid="MOESM1" ref-type="media">2</xref> of the Supplementary Material.</p><p id="Par63">Let <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> be an active cluster, that is, <inline-formula id="IEq56"><alternatives><tex-math id="d33e3521">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$({H}_{[{C}_{i}]},{{{\bf{s}}}}_{[{C}_{i}]})$$\end{document}</tex-math><mml:math id="d33e3526"><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>,</mml:mo><mml:msub><mml:mrow><mml:mi mathvariant="bold">s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq56.gif"/></alternatives></inline-formula> does not define a solvable decoding problem as <inline-formula id="IEq57"><alternatives><tex-math id="d33e3561">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${s}_{[{C}_{i}]}\notin {{\rm{image}}}({H}_{[{C}_{i}]})$$\end{document}</tex-math><mml:math id="d33e3566"><mml:msub><mml:mrow><mml:mi>s</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>&#8713;</mml:mo><mml:mi mathvariant="normal">image</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq57.gif"/></alternatives></inline-formula>. To grow cluster <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>, we consider candidate fault nodes <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub>&#160;&#8712;&#160;<italic toggle="yes">&#923;</italic>(<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>) &#8211; fault nodes not already in <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> but connected to check nodes on its boundary <italic toggle="yes">&#946;</italic>(<italic toggle="yes">C</italic>), see Definition IV.3. The candidate fault node with the highest probability of being in error according to the soft information vector <inline-formula id="IEq58"><alternatives><tex-math id="d33e3637">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{\mathbf{\lambda }}}\in {{\mathbb{R}}}^{n}$$\end{document}</tex-math><mml:math id="d33e3642"><mml:mi mathvariant="bold">&#955;</mml:mi><mml:mo>&#8712;</mml:mo><mml:msup><mml:mrow><mml:mi mathvariant="double-struck">R</mml:mi></mml:mrow><mml:mrow><mml:mi>n</mml:mi></mml:mrow></mml:msup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq43.gif"/></alternatives></inline-formula> is selected. Once <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub> has been chosen, we check whether its neighboring detector nodes are boundary nodes of any other (valid or invalid) clusters i.e., we check for collisions, cf Definition IV.4. If this is not the case, we proceed as follows. We now assume that the active cluster <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> described by sub-matrix <inline-formula id="IEq59"><alternatives><tex-math id="d33e3667">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3672"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> that has a PLU factorization of the form<disp-formula id="Equ7"><label>7</label><alternatives><tex-math id="d33e3688">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}={P}_{i}{L}_{i}{U}_{i},$$\end{document}</tex-math><mml:math id="d33e3694"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi>U</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>,</mml:mo></mml:math><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Article_Equ7.gif"/></alternatives></disp-formula>where <italic toggle="yes">P</italic><sub><italic toggle="yes">i</italic></sub>,&#160;<italic toggle="yes">L</italic><sub><italic toggle="yes">i</italic></sub>,&#160;<italic toggle="yes">U</italic><sub><italic toggle="yes">i</italic></sub> are as in Eq. (<xref rid="Equ6" ref-type="disp-formula">6</xref>). Adding a fault node <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub> to the cluster is equivalent to adding a (sparse) column vector <bold>b</bold> to <inline-formula id="IEq60"><alternatives><tex-math id="d33e3758">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3763"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula>, i.e., <disp-formula id="Equ8"><label>8</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ1_HTML.gif"/></disp-formula> A key insight is that the PLU factorization of the extended matrix <inline-formula id="IEq61"><alternatives><tex-math id="d33e3785">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e3790"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq61.gif"/></alternatives></inline-formula> can be computed through row operation on column <bold>b</bold> alone: it is not necessary to factorize the full matrix <inline-formula id="IEq62"><alternatives><tex-math id="d33e3819">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e3824"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq61.gif"/></alternatives></inline-formula> from scratch. By applying the PLU factorization of <inline-formula id="IEq63"><alternatives><tex-math id="d33e3850">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e3855"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> block-wise to the extended matrix <inline-formula id="IEq64"><alternatives><tex-math id="d33e3871">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e3876"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq61.gif"/></alternatives></inline-formula>, we obtain <disp-formula id="Equ9"><label>9</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ2_HTML.gif"/></disp-formula> where <bold>b</bold><sub><italic toggle="yes">i</italic></sub> is the projection of <bold>b</bold> onto the detectors/row coordinates that are enclosed by <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>. Similarly, <bold>b</bold><sub><italic toggle="yes">i</italic>*</sub> is the projection onto detector coordinates not enclosed by <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>. Importantly, applying the operators <inline-formula id="IEq65"><alternatives><tex-math id="d33e3937">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${L}_{i}^{-1}$$\end{document}</tex-math><mml:math id="d33e3942"><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq65.gif"/></alternatives></inline-formula> and <inline-formula id="IEq66"><alternatives><tex-math id="d33e3953">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${P}_{i}^{T}$$\end{document}</tex-math><mml:math id="d33e3958"><mml:msubsup><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow><mml:mrow><mml:mi>T</mml:mi></mml:mrow></mml:msubsup></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq66.gif"/></alternatives></inline-formula> does not affect the support of <bold>b</bold><sub><italic toggle="yes">i</italic></sub> and <bold>b</bold><sub><italic toggle="yes">i</italic>*</sub>, as both these operators act solely on the support of <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>. Combining this with Eq. <xref rid="Equ9" ref-type="disp-formula">9</xref>, we note that to complete the PLU factorization of <inline-formula id="IEq67"><alternatives><tex-math id="d33e3991">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e3996"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq61.gif"/></alternatives></inline-formula> only <bold>b</bold><sub><italic toggle="yes">i</italic>*</sub> has to be reduced, which has a computational cost proportional to its weight &#8211; crucially only a small constant for bounded LDPC matrices <italic toggle="yes">H</italic>.</p><p id="Par64">We now continue by describing the collision case, where the addition of a fault node to a cluster results in the merging of two clusters. The generalization to the merging of more than two clusters is straightforward.</p><p id="Par65">Suppose that the selected fault node <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub> by which the cluster <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> is grown is connected to a check node in the boundary <italic toggle="yes">&#946;</italic>(<italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub>), with <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>&#160;&#8800;&#160;<italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub>. Let <bold>b</bold> be the column of <italic toggle="yes">H</italic> associated with the fault node <italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub>. Re-ordering its coordinates if necessary, we can write <bold>b</bold> as (<bold>b</bold><sub><italic toggle="yes">i</italic></sub>,&#160;<bold>b</bold><sub><italic toggle="yes">&#8467;</italic></sub>,&#160;<bold>b</bold><sub>*</sub>) where <bold>b</bold><sub><italic toggle="yes">i</italic></sub>,&#160;<bold>b</bold><sub><italic toggle="yes">&#8467;</italic></sub>, and <bold>b</bold><sub>*</sub> are the projections of <bold>b</bold> on the row coordinates contained in <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>, <italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub>, and neither of them, respectively. Thus, using a block matrix notation, for the combined cluster <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>&#160;&#8746;&#160;<italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub>&#160;&#8746;&#160;{<italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub>}, we have <disp-formula id="Equ10"><label>10</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ3_HTML.gif"/></disp-formula> By applying the PLU factorization of <inline-formula id="IEq68"><alternatives><tex-math id="d33e4160">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}]}$$\end{document}</tex-math><mml:math id="d33e4165"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq15.gif"/></alternatives></inline-formula> and <inline-formula id="IEq69"><alternatives><tex-math id="d33e4181">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{\ell }]}$$\end{document}</tex-math><mml:math id="d33e4186"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#8467;</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq69.gif"/></alternatives></inline-formula> block wise, we can put <inline-formula id="IEq70"><alternatives><tex-math id="d33e4203">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup {C}_{\ell }\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e4208"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#8467;</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq70.gif"/></alternatives></inline-formula> into the form <disp-formula id="Equ11"><label>11</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ4_HTML.gif"/></disp-formula> Since <italic toggle="yes">U</italic><sub><italic toggle="yes">i</italic></sub> and <italic toggle="yes">U</italic><sub><italic toggle="yes">&#8467;</italic></sub> are, in general, not full rank, they may contain some zero rows. As a result, the first &#8739;<italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>&#8739;&#160;+&#160;&#8739;<italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub>&#8739; columns are not necessarily in reduced form. To make this issue clearer, we introduce the notation <inline-formula id="IEq71"><alternatives><tex-math id="d33e4270">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${{{\bf{u}}}}_{m}={L}_{m}^{-1}{P}_{m}{{{\bf{b}}}}_{m}$$\end{document}</tex-math><mml:math id="d33e4275"><mml:msub><mml:mrow><mml:mi mathvariant="bold">u</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:mo>=</mml:mo><mml:msubsup><mml:mrow><mml:mi>L</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow><mml:mrow><mml:mo>&#8722;</mml:mo><mml:mn>1</mml:mn></mml:mrow></mml:msubsup><mml:msub><mml:mrow><mml:mi>P</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub><mml:msub><mml:mrow><mml:mi mathvariant="bold">b</mml:mi></mml:mrow><mml:mrow><mml:mi>m</mml:mi></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq71.gif"/></alternatives></inline-formula> for <italic toggle="yes">m</italic>&#160;&#8712;&#160;{<italic toggle="yes">i</italic>,&#160;<italic toggle="yes">&#8467;</italic>} and express the above matrix as <disp-formula id="Equ12"><label>12</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ5_HTML.gif"/></disp-formula> Here, by slight misuse of notation, we group the non-zero rows of <italic toggle="yes">U</italic><sub><italic toggle="yes">m</italic></sub> in the index set (<italic toggle="yes">m</italic>,&#160;&#8226;), and its zero rows in the set (<italic toggle="yes">m</italic>,&#160;&#8869;); we regroup the coordinates of vector <bold>u</bold> accordingly. We remark that the row sets &#8226; and &#8869; are distinct from the row set * identified when writing <bold>b</bold> as the combination of its projection onto row coordinates enclosed by <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub> and outside it. By identifying the appropriate row sets for the clusters <italic toggle="yes">C</italic><sub><italic toggle="yes">i</italic></sub>, <italic toggle="yes">C</italic><sub><italic toggle="yes">&#8467;</italic></sub> and the fault node {<italic toggle="yes">v</italic><sub><italic toggle="yes">j</italic></sub>} as detailed in Eq. (<xref rid="Equ12" ref-type="disp-formula">12</xref>), we can construct a block-swap matrix to bring <inline-formula id="IEq72"><alternatives><tex-math id="d33e4366">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$${H}_{[{C}_{i}\cup {C}_{\ell }\cup \{{v}_{j}\}]}$$\end{document}</tex-math><mml:math id="d33e4371"><mml:msub><mml:mrow><mml:mi>H</mml:mi></mml:mrow><mml:mrow><mml:mrow><mml:mo>[</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>i</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:msub><mml:mrow><mml:mi>C</mml:mi></mml:mrow><mml:mrow><mml:mi>&#8467;</mml:mi></mml:mrow></mml:msub><mml:mo>&#8746;</mml:mo><mml:mrow><mml:mo>{</mml:mo><mml:mrow><mml:msub><mml:mrow><mml:mi>v</mml:mi></mml:mrow><mml:mrow><mml:mi>j</mml:mi></mml:mrow></mml:msub></mml:mrow><mml:mo>}</mml:mo></mml:mrow></mml:mrow><mml:mo>]</mml:mo></mml:mrow></mml:mrow></mml:msub></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq70.gif"/></alternatives></inline-formula> into the form <disp-formula id="Equ13"><label>13</label><graphic position="anchor" orientation="portrait" xlink:href="41467_2025_63214_Equ6_HTML.gif"/></disp-formula> and similarly for its PLU factors. Since the matrix in Eq. <xref rid="Equ13" ref-type="disp-formula">13</xref> has the same form as the one in Eq. <xref rid="Equ8" ref-type="disp-formula">8</xref>, the algorithm can proceed from this point onward as in the case of the addition of a single fault node to a cluster. In conclusion, via a swap transformation, we can effectively reduce the problem of merging two clusters to the problem of adding a single fault node to one cluster.</p></sec><sec id="Sec11"><title>Numerical decoding simulations</title><p id="Par66">For all numerical simulations in this work, we employ a circuit-level noise model that is characterized by a single parameter <italic toggle="yes">p</italic>, the physical error probability. Typically, the standard noise model for each time step is then to assume the following.<list list-type="bullet"><list-item><p id="Par67">Idle qubits are subject to depolarizing errors with probability <italic toggle="yes">p</italic>.</p></list-item><list-item><p id="Par68">Pairs of qubits acted on by two-qubit gates such as CNOT are subject to two-qubit depolarizing errors <italic toggle="yes">after</italic> the gate, that is, any of the 15 non-trivial Pauli operators occurs with probability <italic toggle="yes">p</italic>/15.</p></list-item><list-item><p id="Par69">Qubits initialized in <inline-formula id="IEq73"><alternatives><tex-math id="d33e4441">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\left\vert 0\right\rangle (\left\vert+\right\rangle )$$\end{document}</tex-math><mml:math id="d33e4446"><mml:mfenced close="&#x27E9;" open="&#x2223;"><mml:mrow><mml:mn>0</mml:mn></mml:mrow></mml:mfenced><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mfenced close="&#x27E9;" open="&#x2223;"><mml:mrow><mml:mo>+</mml:mo></mml:mrow></mml:mfenced></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq73.gif"/></alternatives></inline-formula> are flipped to <inline-formula id="IEq74"><alternatives><tex-math id="d33e4459">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\left\vert 1\right\rangle$$\end{document}</tex-math><mml:math id="d33e4464"><mml:mfenced close="&#x27E9;" open="&#x2223;"><mml:mrow><mml:mn>1</mml:mn></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq74.gif"/></alternatives></inline-formula> (<inline-formula id="IEq75"><alternatives><tex-math id="d33e4470">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$\left\vert -\right\rangle$$\end{document}</tex-math><mml:math id="d33e4475"><mml:mfenced close="&#x27E9;" open="&#x2223;"><mml:mrow><mml:mo>&#8722;</mml:mo></mml:mrow></mml:mfenced></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq75.gif"/></alternatives></inline-formula>) with probability <italic toggle="yes">p</italic>.</p></list-item><list-item><p id="Par70">The measurement result of an <italic toggle="yes">X</italic>/<italic toggle="yes">Z</italic> basis measurement is flipped with probability <italic toggle="yes">p</italic>.</p></list-item></list></p><p id="Par71">For surface code simulations, we use the syndrome extraction circuits and noise model provided by Stim<sup><xref ref-type="bibr" rid="CR30">30</xref></sup>. We note that this noise model is similar to the one described above, however, it differs in small details such as that it combines measurement and initialization errors, ignores idling errors and applies a depolarizing channel to data qubits prior to each syndrome measurement cycle. We perform a memory experiment for a single check side (<italic toggle="yes">Z</italic>-checks), called surface_code:rotated_memory_z experiment in Stim, over <italic toggle="yes">d</italic> syndrome extraction cycles for code instances with distance <italic toggle="yes">d</italic>.</p><p id="Par72">The syndrome extraction circuits for the family of HGP codes presented in Section&#160;<xref rid="MOESM1" ref-type="media">3</xref> of the Supplementary Material and results presented in subsection &#8220;Numerical results&#8221; are obtained from the minimum edge coloration of the Tanner graphs associated to the respective parity check matrix, see ref. <sup><xref ref-type="bibr" rid="CR13">13</xref></sup> for details. In particular, we generate associated Stim files of <italic toggle="yes">r</italic>&#160;=&#160;12 noisy syndrome extractions using a publicly available implementation of the aforementioned coloration circuit by Pattison<sup><xref ref-type="bibr" rid="CR57">57</xref></sup>. In this case, the standard circuit-level noise model described at the beginning of this section is employed. We decode <italic toggle="yes">X</italic> and <italic toggle="yes">Z</italic> detectors separately using a (3,&#160;1)&#160;&#8722;&#160;overlapping window decoder. That is, for each decoding round, the decoder obtains the detection events for <italic toggle="yes">w</italic>&#160;=&#160;3 syndrome extraction cycles and computes a correction for the entire window. However, it only applies the correction for a single (<italic toggle="yes">c</italic>&#160;=&#160;1) syndrome extraction cycle, specifically the one that occurred the furthest in the past. For more details on circuit-level overlapping window decoding, see ref. <sup><xref ref-type="bibr" rid="CR58">58</xref></sup>. We have chosen <italic toggle="yes">w</italic>&#160;=&#160;3 as this was the value used in ref. <sup><xref ref-type="bibr" rid="CR13">13</xref></sup>. Note that it is possible that (small) decoding improvements could be observed by considering larger values of (<italic toggle="yes">w</italic>,&#160;<italic toggle="yes">c</italic>) for the overlapping window decoder.</p><p id="Par73">The BB codes are simulated using the syndrome extraction circuits specified in ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup>, and the Stim files are generated using the code in ref. <sup><xref ref-type="bibr" rid="CR59">59</xref></sup>. There, the authors recreate the circuit-level noise model described in ref. <sup><xref ref-type="bibr" rid="CR12">12</xref></sup> which, up to minor details, implements the noise model described at the beginning of this section. Similar to the HGP codes mentioned above, we decode <italic toggle="yes">X</italic> and <italic toggle="yes">Z</italic> decoders separately. Analogous to our surface code experiments, we simulate for a distance <italic toggle="yes">d</italic> code <italic toggle="yes">d</italic> rounds of syndrome extraction and decode the full syndrome history at once. As the BB codes are CSS codes, we decode <italic toggle="yes">X</italic> and <italic toggle="yes">Z</italic> detectors separately.</p><p id="Par74">If not specified otherwise, we have used the min-sum algorithm for BP, allowing for a maximum of 30 iterations with a scaling factor of <italic toggle="yes">&#945;</italic>&#160;=&#160;0.625, using the parallel update schedule. We have not optimized these parameters and believe that an improved decoding performance, in terms of speed and (or) accuracy, can be achieved by further tweaking these parameters.</p></sec><sec id="Sec12"><title>Parallel algorithm</title><p id="Par75">We propose a parallel version of the LSD algorithm (P-LSD) in Section&#160;<xref rid="MOESM1" ref-type="media">2</xref> of the Supplementary Material that uses a parallel data structure, inspired by refs. <sup><xref ref-type="bibr" rid="CR60">60</xref>,<xref ref-type="bibr" rid="CR61">61</xref></sup>, to minimize synchronization bottlenecks. We discuss the parallel algorithm in more detail in Section&#160;<xref rid="MOESM1" ref-type="media">2</xref> of the Supplementary Material. There, we derive a bound on the parallel <italic toggle="yes">depth</italic> of P-LSD, that is, roughly the maximum overhead per parallel resource of the algorithm. We show that the depth is <inline-formula id="IEq76"><alternatives><tex-math id="d33e4631">\documentclass[12pt]{minimal}
				\usepackage{amsmath}
				\usepackage{wasysym} 
				\usepackage{amsfonts} 
				\usepackage{amssymb} 
				\usepackage{amsbsy}
				\usepackage{mathrsfs}
				\usepackage{upgreek}
				\setlength{\oddsidemargin}{-69pt}
				\begin{document}$$O({\mathrm{polylog}}\,(n)+{\kappa }^{3})$$\end{document}</tex-math><mml:math id="d33e4636"><mml:mi>O</mml:mi><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi mathvariant="normal">polylog</mml:mi><mml:mspace width="0.25em"/><mml:mrow><mml:mo>(</mml:mo><mml:mrow><mml:mi>n</mml:mi></mml:mrow><mml:mo>)</mml:mo></mml:mrow><mml:mo>+</mml:mo><mml:msup><mml:mrow><mml:mi>&#954;</mml:mi></mml:mrow><mml:mrow><mml:mn>3</mml:mn></mml:mrow></mml:msup></mml:mrow><mml:mo>)</mml:mo></mml:mrow></mml:math><inline-graphic xlink:href="41467_2025_63214_Article_IEq76.gif"/></alternatives></inline-formula> in the worst-case, where <italic toggle="yes">n</italic> is the number of vertices of the decoding graph and <italic toggle="yes">&#954;</italic> is the maximum cluster size. A crucial factor in the runtime overhead of P-LSD is given by the merge and factorization operations. We contain this overhead by (i) using the parallel union-find data structure of ref. <sup><xref ref-type="bibr" rid="CR60">60</xref></sup> for cluster tracking and (ii) using parallel on-the-fly elimination to factorize the associated matrices. If we assume sufficient parallel resources, the overall runtime of parallel LSD is dominated by the complexity of computing the decoding solution for the largest cluster. To estimate the expected overhead induced by the cluster sizes concretely, we (i) investigate analytical bounds and (ii) conduct numerical experiments to analyze the statistical distribution of clusters for several code families, see Section&#160;<xref rid="MOESM1" ref-type="media">1</xref> of the Supplementary Material.</p></sec></sec><sec id="Sec13" sec-type="supplementary-material"><title>Supplementary information</title><p>
<supplementary-material content-type="local-data" id="MOESM1" position="float" orientation="portrait"><media xlink:href="41467_2025_63214_MOESM1_ESM.pdf" position="float" orientation="portrait"><caption><p>Supplementary Information</p></caption></media></supplementary-material>
<supplementary-material content-type="local-data" id="MOESM2" position="float" orientation="portrait"><media xlink:href="41467_2025_63214_MOESM2_ESM.pdf" position="float" orientation="portrait"><caption><p>Transparent Peer Review file</p></caption></media></supplementary-material>
</p></sec></body><back><fn-group><fn><p><bold>Publisher&#8217;s note</bold> Springer Nature remains neutral with regard to jurisdictional claims in published maps and institutional affiliations.</p></fn><fn><p>These authors contributed equally: Timo Hillmann, Lucas Berent.</p></fn></fn-group><sec><title>Supplementary information</title><p>The online version contains supplementary material available at 10.1038/s41467-025-63214-7.</p></sec><ack><title>Acknowledgements</title><p>The authors would like to thank C.A. Pattison for providing the code to generate the coloration circuits for the HGP code family via Github. T.H. acknowledges the financial support from the Chalmers Excellence Initiative Nano and the Knut and Alice Wallenberg Foundation through the Wallenberg Centre for Quantum Technology (WACQT). This work was done in part while L.B. was visiting the Simons Institute for the Theory of Computing. L.B. and R.W. acknowledge funding from the European Research Council (ERC) under the European Union&#8217;s Horizon 2020 research and innovation program (grant agreement No. 101001318) and Millenion, grant agreement No. 101114305). This work was part of the Munich Quantum Valley, which is supported by the Bavarian state government with funds from the Hightech Agenda Bayern Plus, and has been supported by the BMWK on the basis of a decision by the German Bundestag through project QuaST, as well as by the BMK, BMDW, and the State of Upper Austria in the frame of the COMET program (managed by the FFG). J. R. is funded by an EPSRC Quantum Career Acceleration Fellowship (grant code: UKRI1224). J. R. further acknowledges support from EPSRC grants EP/T001062/1 and EP/X026167/1. The Berlin team has also been funded by BMBF (RealistiQ, QSolid), the DFG (CRC 183), the Munich Quantum Valley, the Einstein Research Unit on Quantum Devices, the Quantum Flagship (PasQuans2, Millenion), and the European Research Council (ERC DebuQC). For Millenion and the Munich Quantum Valley, this work is the result of joint-node collaboration.</p></ack><notes notes-type="author-contribution"><title>Author contributions</title><p>T.H., L.B., and J.R. implemented and conceived the LSD algorithm. T.H. performed the numerical decoding simulations and implemented the overlapping window decoder. A.Q. performed the numerical cluster simulations and formulated the cluster bounds. T.H., L.B., A.Q., J.E., R.W. and J.R. drafted the manuscript and contributed to analytical considerations.</p></notes><notes notes-type="peer-review"><title>Peer review</title><sec id="FPar5"><title>Peer review information</title><p id="Par76"><italic toggle="yes">Nature Communications</italic> thanks the anonymous reviewer(s) for their contribution to the peer review of this work. A peer review file is available.</p></sec></notes><notes notes-type="funding-information"><title>Funding</title><p>Open Access funding enabled and organized by Projekt DEAL.</p></notes><notes notes-type="data-availability"><title>Data availability</title><p>The simulation data generated in this study has been deposited in the Zenodo database and is available under<sup><xref ref-type="bibr" rid="CR62">62</xref></sup>.</p></notes><notes notes-type="data-availability"><title>Code availability</title><p>The proposed algorithm and scripts to run the numerical experiments to generate the results presented above is publicly available on Github<sup><xref ref-type="bibr" rid="CR42">42</xref></sup>.</p></notes><notes id="FPar6" notes-type="COI-statement"><title>Competing interests</title><p id="Par77">The authors declare no competing interests.</p></notes><ref-list id="Bib1"><title>References</title><ref id="CR1"><label>1.</label><citation-alternatives><element-citation id="ec-CR1" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Breuckmann</surname><given-names>NP</given-names></name><name name-style="western"><surname>Eberhardt</surname><given-names>JN</given-names></name></person-group><article-title>Quantum low-density parity-check codes</article-title><source>PRX Quantum</source><year>2021</year><volume>2</volume><fpage>040101</fpage></element-citation><mixed-citation id="mc-CR1" publication-type="journal">Breuckmann, N. P. &amp; Eberhardt, J. N. Quantum low-density parity-check codes. <italic toggle="yes">PRX Quantum</italic><bold>2</bold>, 040101 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR2"><label>2.</label><citation-alternatives><element-citation id="ec-CR2" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Dennis</surname><given-names>E</given-names></name><name name-style="western"><surname>Kitaev</surname><given-names>AJ</given-names></name><name name-style="western"><surname>Landahl</surname><given-names>A</given-names></name><name name-style="western"><surname>Preskill</surname><given-names>J</given-names></name></person-group><article-title>Topological quantum memory</article-title><source>J. Math. Phys.</source><year>2002</year><volume>43</volume><fpage>4452</fpage></element-citation><mixed-citation id="mc-CR2" publication-type="journal">Dennis, E., Kitaev, A. J., Landahl, A. &amp; Preskill, J. Topological quantum memory. <italic toggle="yes">J. Math. Phys.</italic><bold>43</bold>, 4452 (2002).</mixed-citation></citation-alternatives></ref><ref id="CR3"><label>3.</label><citation-alternatives><element-citation id="ec-CR3" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fowler</surname><given-names>AG</given-names></name><name name-style="western"><surname>Mariantoni</surname><given-names>M</given-names></name><name name-style="western"><surname>Martinis</surname><given-names>JM</given-names></name><name name-style="western"><surname>Cleland</surname><given-names>AN</given-names></name></person-group><article-title>Surface codes: Towards practical large-scale quantum computation</article-title><source>Phys. Rev. A</source><year>2012</year><volume>86</volume><fpage>032324</fpage></element-citation><mixed-citation id="mc-CR3" publication-type="journal">Fowler, A. G., Mariantoni, M., Martinis, J. M. &amp; Cleland, A. N. Surface codes: Towards practical large-scale quantum computation. <italic toggle="yes">Phys. Rev. A</italic><bold>86</bold>, 032324 (2012).</mixed-citation></citation-alternatives></ref><ref id="CR4"><label>4.</label><citation-alternatives><element-citation id="ec-CR4" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kitaev</surname><given-names>AJ</given-names></name></person-group><article-title>Fault-tolerant quantum computation by anyons</article-title><source>Ann. Phys.</source><year>2003</year><volume>303</volume><fpage>2</fpage></element-citation><mixed-citation id="mc-CR4" publication-type="journal">Kitaev, A. J. Fault-tolerant quantum computation by anyons. <italic toggle="yes">Ann. Phys.</italic><bold>303</bold>, 2 (2003).</mixed-citation></citation-alternatives></ref><ref id="CR5"><label>5.</label><citation-alternatives><element-citation id="ec-CR5" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gallager</surname><given-names>RG</given-names></name></person-group><article-title>Low-density parity-check codes</article-title><source>IRE Trans. Inf. Theory</source><year>1962</year><volume>8</volume><fpage>21</fpage></element-citation><mixed-citation id="mc-CR5" publication-type="journal">Gallager, R. G. Low-density parity-check codes. <italic toggle="yes">IRE Trans. Inf. Theory</italic><bold>8</bold>, 21 (1962).</mixed-citation></citation-alternatives></ref><ref id="CR6"><label>6.</label><citation-alternatives><element-citation id="ec-CR6" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Richardson</surname><given-names>T</given-names></name><name name-style="western"><surname>Kudekar</surname><given-names>S</given-names></name></person-group><article-title>Design of low-density parity check codes for 5g new radio</article-title><source>IEEE Commun. Mag.</source><year>2018</year><volume>56</volume><fpage>28</fpage></element-citation><mixed-citation id="mc-CR6" publication-type="journal">Richardson, T. &amp; Kudekar, S. Design of low-density parity check codes for 5g new radio. <italic toggle="yes">IEEE Commun. Mag.</italic><bold>56</bold>, 28 (2018).</mixed-citation></citation-alternatives></ref><ref id="CR7"><label>7.</label><citation-alternatives><element-citation id="ec-CR7" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Breuckmann</surname><given-names>NP</given-names></name><name name-style="western"><surname>Eberhardt</surname><given-names>JN</given-names></name></person-group><article-title>Balanced product quantum codes</article-title><source>IEEE Trans. Inf. Theory</source><year>2021</year><volume>67</volume><fpage>6653</fpage></element-citation><mixed-citation id="mc-CR7" publication-type="journal">Breuckmann, N. P. &amp; Eberhardt, J. N. Balanced product quantum codes. <italic toggle="yes">IEEE Trans. Inf. Theory</italic><bold>67</bold>, 6653 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR8"><label>8.</label><mixed-citation publication-type="other">Panteleev, P. and Kalachev, G., Asymptotically good Quantum and locally testable classical LDPC codes, in 10.1145/3519935.3520017<italic toggle="yes">Proceedings of the 54th Annual ACM SIGACT Symposium on Theory of Computing</italic>, STOC 2022 (Association for Computing Machinery, New York, NY, USA, 2022) pp. 375&#8211;388.</mixed-citation></ref><ref id="CR9"><label>9.</label><mixed-citation publication-type="other">Gottesman, D., Fault-tolerant quantum computation with constant overhead, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/1310.2984">https://arxiv.org/abs/1310.2984</ext-link> arxiv:1310.2984 [quant-ph] (2014).</mixed-citation></ref><ref id="CR10"><label>10.</label><mixed-citation publication-type="other">Leverrier, A. and Z&#233;mor, G., Quantum Tanner codes, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2202.13641">https://arxiv.org/abs/2202.13641</ext-link> arxiv:2202.13641 [quant-ph] (2022).</mixed-citation></ref><ref id="CR11"><label>11.</label><citation-alternatives><element-citation id="ec-CR11" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Panteleev</surname><given-names>P</given-names></name><name name-style="western"><surname>Kalachev</surname><given-names>G</given-names></name></person-group><article-title>Degenerate quantum LDPC codes with good finite length performance</article-title><source>Quantum</source><year>2021</year><volume>5</volume><fpage>585</fpage></element-citation><mixed-citation id="mc-CR11" publication-type="journal">Panteleev, P. &amp; Kalachev, G. Degenerate quantum LDPC codes with good finite length performance. <italic toggle="yes">Quantum</italic><bold>5</bold>, 585 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR12"><label>12.</label><citation-alternatives><element-citation id="ec-CR12" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bravyi</surname><given-names>S</given-names></name><etal/></person-group><article-title>High-threshold and low-overhead fault-tolerant quantum memory</article-title><source>Nature</source><year>2024</year><volume>627</volume><fpage>778</fpage><pub-id pub-id-type="pmid">38538939</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41586-024-07107-7</pub-id><pub-id pub-id-type="pmcid">PMC10972743</pub-id></element-citation><mixed-citation id="mc-CR12" publication-type="journal">Bravyi, S. et al. High-threshold and low-overhead fault-tolerant quantum memory. <italic toggle="yes">Nature</italic><bold>627</bold>, 778 (2024).<pub-id pub-id-type="pmid">38538939</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41586-024-07107-7</pub-id><pub-id pub-id-type="pmcid">PMC10972743</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR13"><label>13.</label><mixed-citation publication-type="other">Xu, Q. et al. Constant-overhead fault-tolerant quantum computation with reconfigurable atom arrays. <italic toggle="yes">Nat. Phys. 1</italic> (2024).</mixed-citation></ref><ref id="CR14"><label>14.</label><citation-alternatives><element-citation id="ec-CR14" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simmons</surname><given-names>S</given-names></name></person-group><article-title>Scalable fault-tolerant quantum technologies with silicon color centers</article-title><source>PRX Quantum</source><year>2024</year><volume>5</volume><fpage>010102</fpage></element-citation><mixed-citation id="mc-CR14" publication-type="journal">Simmons, S. Scalable fault-tolerant quantum technologies with silicon color centers. <italic toggle="yes">PRX Quantum</italic><bold>5</bold>, 010102 (2024).</mixed-citation></citation-alternatives></ref><ref id="CR15"><label>15.</label><citation-alternatives><element-citation id="ec-CR15" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bluvstein</surname><given-names>D</given-names></name><etal/></person-group><article-title>Logical quantum processor based on reconfigurable atom arrays</article-title><source>Nature</source><year>2024</year><volume>626</volume><fpage>58</fpage><pub-id pub-id-type="pmid">38056497</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41586-023-06927-3</pub-id><pub-id pub-id-type="pmcid">PMC10830422</pub-id></element-citation><mixed-citation id="mc-CR15" publication-type="journal">Bluvstein, D. et al. Logical quantum processor based on reconfigurable atom arrays. <italic toggle="yes">Nature</italic><bold>626</bold>, 58 (2024).<pub-id pub-id-type="pmid">38056497</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41586-023-06927-3</pub-id><pub-id pub-id-type="pmcid">PMC10830422</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR16"><label>16.</label><citation-alternatives><element-citation id="ec-CR16" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tzitrin</surname><given-names>I</given-names></name><etal/></person-group><article-title>Fault-tolerant quantum computation with static linear optics</article-title><source>PRX Quantum</source><year>2021</year><volume>2</volume><fpage>040353</fpage></element-citation><mixed-citation id="mc-CR16" publication-type="journal">Tzitrin, I. et al. Fault-tolerant quantum computation with static linear optics. <italic toggle="yes">PRX Quantum</italic><bold>2</bold>, 040353 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR17"><label>17.</label><citation-alternatives><element-citation id="ec-CR17" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bartolucci</surname><given-names>S</given-names></name><etal/></person-group><article-title>Fusion-based quantum computation</article-title><source>Nat. Commun.</source><year>2023</year><volume>14</volume><fpage>912</fpage><pub-id pub-id-type="pmid">36805650</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-023-36493-1</pub-id><pub-id pub-id-type="pmcid">PMC9938229</pub-id></element-citation><mixed-citation id="mc-CR17" publication-type="journal">Bartolucci, S. et al. Fusion-based quantum computation. <italic toggle="yes">Nat. Commun.</italic><bold>14</bold>, 912 (2023).<pub-id pub-id-type="pmid">36805650</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-023-36493-1</pub-id><pub-id pub-id-type="pmcid">PMC9938229</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR18"><label>18.</label><mixed-citation publication-type="other">Bacon, D. Software of QIP, by QIP, and for QIP (Mach 2022).</mixed-citation></ref><ref id="CR19"><label>19.</label><mixed-citation publication-type="other">Beverland, M.E. et al. Assessing requirements to scale to practical quantum advantage, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2211.07629">https://arxiv.org/abs/2211.07629</ext-link> arxiv:2211.07629 [quant-ph] (2022).</mixed-citation></ref><ref id="CR20"><label>20.</label><citation-alternatives><element-citation id="ec-CR20" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Skoric</surname><given-names>L</given-names></name><name name-style="western"><surname>Browne</surname><given-names>DE</given-names></name><name name-style="western"><surname>Barnes</surname><given-names>KM</given-names></name><name name-style="western"><surname>Gillespie</surname><given-names>NI</given-names></name><name name-style="western"><surname>Campbell</surname><given-names>ET</given-names></name></person-group><article-title>Parallel window decoding enables scalable fault tolerant quantum computation</article-title><source>Nat. Commun.</source><year>2023</year><volume>14</volume><fpage>7040</fpage><pub-id pub-id-type="pmid">37923766</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-023-42482-1</pub-id><pub-id pub-id-type="pmcid">PMC10624853</pub-id></element-citation><mixed-citation id="mc-CR20" publication-type="journal">Skoric, L., Browne, D. E., Barnes, K. M., Gillespie, N. I. &amp; Campbell, E. T. Parallel window decoding enables scalable fault tolerant quantum computation. <italic toggle="yes">Nat. Commun.</italic><bold>14</bold>, 7040 (2023).<pub-id pub-id-type="pmid">37923766</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-023-42482-1</pub-id><pub-id pub-id-type="pmcid">PMC10624853</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR21"><label>21.</label><citation-alternatives><element-citation id="ec-CR21" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Roffe</surname><given-names>J</given-names></name><name name-style="western"><surname>White</surname><given-names>DR</given-names></name><name name-style="western"><surname>Burton</surname><given-names>S</given-names></name><name name-style="western"><surname>Campbell</surname><given-names>E</given-names></name></person-group><article-title>Decoding across the quantum low-density parity-check code landscape</article-title><source>Phys. Rev. Res.</source><year>2020</year><volume>2</volume><fpage>043423</fpage></element-citation><mixed-citation id="mc-CR21" publication-type="journal">Roffe, J., White, D. R., Burton, S. &amp; Campbell, E. Decoding across the quantum low-density parity-check code landscape. <italic toggle="yes">Phys. Rev. Res.</italic><bold>2</bold>, 043423 (2020).</mixed-citation></citation-alternatives></ref><ref id="CR22"><label>22.</label><citation-alternatives><element-citation id="ec-CR22" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>MacKay</surname><given-names>DJC</given-names></name><name name-style="western"><surname>Neal</surname><given-names>RM</given-names></name></person-group><article-title>Near shannon limit performance of low density parity check codes</article-title><source>Electron. Lett.</source><year>1997</year><volume>33</volume><fpage>457</fpage></element-citation><mixed-citation id="mc-CR22" publication-type="journal">MacKay, D. J. C. &amp; Neal, R. M. Near shannon limit performance of low density parity check codes. <italic toggle="yes">Electron. Lett.</italic><bold>33</bold>, 457 (1997).</mixed-citation></citation-alternatives></ref><ref id="CR23"><label>23.</label><citation-alternatives><element-citation id="ec-CR23" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Raveendran</surname><given-names>N</given-names></name><name name-style="western"><surname>Vasic</surname><given-names>B</given-names></name></person-group><article-title>Trapping sets of quantum LDPC codes</article-title><source>Quantum</source><year>2021</year><volume>5</volume><fpage>562</fpage></element-citation><mixed-citation id="mc-CR23" publication-type="journal">Raveendran, N. &amp; Vasic, B. Trapping sets of quantum LDPC codes. <italic toggle="yes">Quantum</italic><bold>5</bold>, 562 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR24"><label>24.</label><mixed-citation publication-type="other">Morris, K.D., Pllaha, T. and Kelley, C.A., Analysis of syndrome-based iterative decoder failure of QLDPC codes, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2307.14532">https://arxiv.org/abs/2307.14532</ext-link> arxiv:2307.14532 [cs, math] (2023).</mixed-citation></ref><ref id="CR25"><label>25.</label><citation-alternatives><element-citation id="ec-CR25" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fossorier</surname><given-names>MPC</given-names></name><name name-style="western"><surname>Lin</surname><given-names>S</given-names></name></person-group><article-title>Soft-decision decoding of linear block codes based on ordered statistics</article-title><source>IEEE Trans. Inf. Theory</source><year>1995</year><volume>41</volume><fpage>1379</fpage></element-citation><mixed-citation id="mc-CR25" publication-type="journal">Fossorier, M. P. C. &amp; Lin, S. Soft-decision decoding of linear block codes based on ordered statistics. <italic toggle="yes">IEEE Trans. Inf. Theory</italic><bold>41</bold>, 1379 (1995).</mixed-citation></citation-alternatives></ref><ref id="CR26"><label>26.</label><citation-alternatives><element-citation id="ec-CR26" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Fossorier</surname><given-names>MPC</given-names></name><name name-style="western"><surname>Lin</surname><given-names>S</given-names></name><name name-style="western"><surname>Snyders</surname><given-names>J</given-names></name></person-group><article-title>Reliability-based syndrome decoding of linear block codes</article-title><source>IEEE Trans. Inf. Theory</source><year>1998</year><volume>44</volume><fpage>388</fpage></element-citation><mixed-citation id="mc-CR26" publication-type="journal">Fossorier, M. P. C., Lin, S. &amp; Snyders, J. Reliability-based syndrome decoding of linear block codes. <italic toggle="yes">IEEE Trans. Inf. Theory</italic><bold>44</bold>, 388 (1998).</mixed-citation></citation-alternatives></ref><ref id="CR27"><label>27.</label><citation-alternatives><element-citation id="ec-CR27" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Valls</surname><given-names>J</given-names></name><name name-style="western"><surname>Garcia-Herrero</surname><given-names>F</given-names></name><name name-style="western"><surname>Raveendran</surname><given-names>N</given-names></name><name name-style="western"><surname>Vasi&#263;</surname><given-names>B</given-names></name></person-group><article-title>Syndrome-based min-sum vs OSD-0 decoders: FPGA implementation and analysis for quantum LDPC codes</article-title><source>IEEE Access</source><year>2021</year><volume>9</volume><fpage>138734</fpage></element-citation><mixed-citation id="mc-CR27" publication-type="journal">Valls, J., Garcia-Herrero, F., Raveendran, N. &amp; Vasi&#263;, B. Syndrome-based min-sum vs OSD-0 decoders: FPGA implementation and analysis for quantum LDPC codes. <italic toggle="yes">IEEE Access</italic><bold>9</bold>, 138734 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR28"><label>28.</label><citation-alternatives><element-citation id="ec-CR28" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Koren</surname><given-names>Y</given-names></name><name name-style="western"><surname>Bell</surname><given-names>R</given-names></name><name name-style="western"><surname>Volinsky</surname><given-names>C</given-names></name></person-group><article-title>Matrix factorization techniques for recommender systems</article-title><source>Computer</source><year>2009</year><volume>42</volume><fpage>30</fpage></element-citation><mixed-citation id="mc-CR28" publication-type="journal">Koren, Y., Bell, R. &amp; Volinsky, C. Matrix factorization techniques for recommender systems. <italic toggle="yes">Computer</italic><bold>42</bold>, 30 (2009).</mixed-citation></citation-alternatives></ref><ref id="CR29"><label>29.</label><mixed-citation publication-type="other">Boche, H., Calderbank, R., Kutyniok, G. and Vyb&#237;ral, J., A survey of compressed sensing, in 10.1007/978-3-319-16042-9_1<italic toggle="yes">Compressed Sensing and its Applications</italic>, edited by Boche, H. Calderbank, R. Kutyniok, G. and Vyb&#237;ral, J. (Springer) series Title: Applied and Numerical Harmonic Analysis.</mixed-citation></ref><ref id="CR30"><label>30.</label><citation-alternatives><element-citation id="ec-CR30" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Gidney</surname><given-names>C</given-names></name></person-group><article-title>Stim: a fast stabilizer circuit simulator</article-title><source>Quantum</source><year>2021</year><volume>5</volume><fpage>497</fpage></element-citation><mixed-citation id="mc-CR30" publication-type="journal">Gidney, C. Stim: a fast stabilizer circuit simulator. <italic toggle="yes">Quantum</italic><bold>5</bold>, 497 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR31"><label>31.</label><mixed-citation publication-type="other">Fang, W. and Ying, M., Symphase: Phase symbolization for fast simulation of stabilizer circuits, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2311.03906">https://arxiv.org/abs/2311.03906</ext-link> arxiv:2311.03906 [quant-ph] (2023).</mixed-citation></ref><ref id="CR32"><label>32.</label><mixed-citation publication-type="other">Derks, P.J.H., Townsend-Teague, A., Burchards, A.G. and Eisert, J. Designing fault-tolerant circuits using detector error models, 10.48550/arXiv.2407.13826 (2024).</mixed-citation></ref><ref id="CR33"><label>33.</label><mixed-citation publication-type="other">Pattison, C.A., Beverland, M.E., da Silva, M.P. and Delfosse, N., Improved quantum error correction using soft information, <italic toggle="yes">arXiv:2107.13589</italic>, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2107.13589">https://arxiv.org/abs/2107.13589</ext-link> arxiv:2107.13589 [quant-ph] (2021).</mixed-citation></ref><ref id="CR34"><label>34.</label><mixed-citation publication-type="other">Raveendran, N., Rengaswamy, N., Pradhan, A.K. and Vasi&#263;, B., Soft syndrome decoding of quantum ldpc codes for joint correction of data and syndrome errors, in 10.1109/QCE53715.2022.00047<italic toggle="yes">2022 IEEE International Conference on Quantum Computing and Engineering (QCE)</italic> (IEEE, 2022) pp. 275&#8211;281.</mixed-citation></ref><ref id="CR35"><label>35.</label><citation-alternatives><element-citation id="ec-CR35" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Berent</surname><given-names>L</given-names></name><name name-style="western"><surname>Hillmann</surname><given-names>T</given-names></name><name name-style="western"><surname>Eisert</surname><given-names>J</given-names></name><name name-style="western"><surname>Wille</surname><given-names>R</given-names></name><name name-style="western"><surname>Roffe</surname><given-names>J</given-names></name></person-group><article-title>Analog information decoding of bosonic quantum low-density parity-check codes</article-title><source>PRX Quantum</source><year>2024</year><volume>5</volume><fpage>020349</fpage><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-025-63214-7</pub-id><pub-id pub-id-type="pmcid">PMC12405505</pub-id><pub-id pub-id-type="pmid">40897712</pub-id></element-citation><mixed-citation id="mc-CR35" publication-type="journal">Berent, L., Hillmann, T., Eisert, J., Wille, R. &amp; Roffe, J. Analog information decoding of bosonic quantum low-density parity-check codes. <italic toggle="yes">PRX Quantum</italic><bold>5</bold>, 020349 (2024).<pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-025-63214-7</pub-id><pub-id pub-id-type="pmcid">PMC12405505</pub-id><pub-id pub-id-type="pmid">40897712</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR36"><label>36.</label><citation-alternatives><element-citation id="ec-CR36" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Bourassa</surname><given-names>JE</given-names></name><etal/></person-group><article-title>Blueprint for a scalable photonic fault-tolerant quantum computer</article-title><source>Quantum</source><year>2021</year><volume>5</volume><fpage>392</fpage></element-citation><mixed-citation id="mc-CR36" publication-type="journal">Bourassa, J. E. et al. Blueprint for a scalable photonic fault-tolerant quantum computer. <italic toggle="yes">Quantum</italic><bold>5</bold>, 392 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR37"><label>37.</label><citation-alternatives><element-citation id="ec-CR37" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Vuillot</surname><given-names>C</given-names></name><name name-style="western"><surname>Asasi</surname><given-names>H</given-names></name><name name-style="western"><surname>Wang</surname><given-names>Y</given-names></name><name name-style="western"><surname>Pryadko</surname><given-names>LP</given-names></name><name name-style="western"><surname>Terhal</surname><given-names>BM</given-names></name></person-group><article-title>Quantum error correction with the toric Gottesman-Kitaev-Preskill code</article-title><source>Phys. Rev. A</source><year>2019</year><volume>99</volume><fpage>032344</fpage></element-citation><mixed-citation id="mc-CR37" publication-type="journal">Vuillot, C., Asasi, H., Wang, Y., Pryadko, L. P. &amp; Terhal, B. M. Quantum error correction with the toric Gottesman-Kitaev-Preskill code. <italic toggle="yes">Phys. Rev. A</italic><bold>99</bold>, 032344 (2019).</mixed-citation></citation-alternatives></ref><ref id="CR38"><label>38.</label><citation-alternatives><element-citation id="ec-CR38" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Higgott</surname><given-names>O</given-names></name><name name-style="western"><surname>Breuckmann</surname><given-names>NP</given-names></name></person-group><article-title>Improved single-shot decoding of higher-dimensional hypergraph-product codes</article-title><source>PRX Quantum</source><year>2023</year><volume>4</volume><fpage>020332</fpage></element-citation><mixed-citation id="mc-CR38" publication-type="journal">Higgott, O. &amp; Breuckmann, N. P. Improved single-shot decoding of higher-dimensional hypergraph-product codes. <italic toggle="yes">PRX Quantum</italic><bold>4</bold>, 020332 (2023).</mixed-citation></citation-alternatives></ref><ref id="CR39"><label>39.</label><mixed-citation publication-type="other">Cain, M. et al. Correlated decoding of logical algorithms with transversal gates, 10.48550/arXiv.2403.03272 (2024).<pub-id pub-id-type="doi" assigning-authority="pmc">10.1103/PhysRevLett.133.240602</pub-id><pub-id pub-id-type="pmid">39750348</pub-id></mixed-citation></ref><ref id="CR40"><label>40.</label><mixed-citation publication-type="other">Delfosse, N., Londe, V. and Beverland, M.E., Toward a union-find decoder for quantum LDPC codes, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2103.08049">https://arxiv.org/abs/2103.08049</ext-link> arxiv:2103.08049 [quant-ph] (2021).</mixed-citation></ref><ref id="CR41"><label>41.</label><citation-alternatives><element-citation id="ec-CR41" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kovalev</surname><given-names>AA</given-names></name><name name-style="western"><surname>Pryadko</surname><given-names>LP</given-names></name></person-group><article-title>Quantum Kronecker sum-product low-density parity-check codes with finite rate</article-title><source>Phys. Rev. A</source><year>2013</year><volume>88</volume><fpage>012311</fpage></element-citation><mixed-citation id="mc-CR41" publication-type="journal">Kovalev, A. A. &amp; Pryadko, L. P. Quantum Kronecker sum-product low-density parity-check codes with finite rate. <italic toggle="yes">Phys. Rev. A</italic><bold>88</bold>, 012311 (2013).</mixed-citation></citation-alternatives></ref><ref id="CR42"><label>42.</label><mixed-citation publication-type="other">Roffe, J., LDPC: Python tools for low density parity check codes, <ext-link ext-link-type="uri" xlink:href="https://github.com/quantumgizmos/ldpc">https://github.com/quantumgizmos/ldpc</ext-link> (2022).</mixed-citation></ref><ref id="CR43"><label>43.</label><citation-alternatives><element-citation id="ec-CR43" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Tillich</surname><given-names>J-P</given-names></name><name name-style="western"><surname>Z&#233;mor</surname><given-names>G</given-names></name></person-group><article-title>Quantum LDPC codes with positive rate and minimum distance proportional to the square root of the blocklength</article-title><source>IEEE Trans. Inf. Theory</source><year>2014</year><volume>60</volume><fpage>1193</fpage></element-citation><mixed-citation id="mc-CR43" publication-type="journal">Tillich, J.-P. &amp; Z&#233;mor, G. Quantum LDPC codes with positive rate and minimum distance proportional to the square root of the blocklength. <italic toggle="yes">IEEE Trans. Inf. Theory</italic><bold>60</bold>, 1193 (2014).</mixed-citation></citation-alternatives></ref><ref id="CR44"><label>44.</label><citation-alternatives><element-citation id="ec-CR44" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Higgott</surname><given-names>O</given-names></name><name name-style="western"><surname>Bohdanowicz</surname><given-names>TC</given-names></name><name name-style="western"><surname>Kubica</surname><given-names>A</given-names></name><name name-style="western"><surname>Flammia</surname><given-names>ST</given-names></name><name name-style="western"><surname>Campbell</surname><given-names>ET</given-names></name></person-group><article-title>Improved decoding of circuit noise and fragile boundaries of tailored surface codes</article-title><source>Phys. Rev. X</source><year>2023</year><volume>13</volume><fpage>031007</fpage></element-citation><mixed-citation id="mc-CR44" publication-type="journal">Higgott, O., Bohdanowicz, T. C., Kubica, A., Flammia, S. T. &amp; Campbell, E. T. Improved decoding of circuit noise and fragile boundaries of tailored surface codes. <italic toggle="yes">Phys. Rev. X</italic><bold>13</bold>, 031007 (2023).</mixed-citation></citation-alternatives></ref><ref id="CR45"><label>45.</label><mixed-citation publication-type="other">Tremblay, M.A., Delfosse, N. and Beverland, M.E., Constant-overhead quantum error correction with thin planar connectivity, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2109.14609">https://arxiv.org/abs/2109.14609</ext-link> arxiv:2109.14609 [quant-ph] (2021).<pub-id pub-id-type="doi" assigning-authority="pmc">10.1103/PhysRevLett.129.050504</pub-id><pub-id pub-id-type="pmid">35960553</pub-id></mixed-citation></ref><ref id="CR46"><label>46.</label><mixed-citation publication-type="other">Strang, G., <italic toggle="yes">Introduction to linear algebra</italic> (SIAM, 2022)</mixed-citation></ref><ref id="CR47"><label>47.</label><citation-alternatives><element-citation id="ec-CR47" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Terhal</surname><given-names>BM</given-names></name></person-group><article-title>Quantum error correction for quantum memories</article-title><source>Rev. Mod. Phys.</source><year>2015</year><volume>87</volume><fpage>307</fpage></element-citation><mixed-citation id="mc-CR47" publication-type="journal">Terhal, B. M. Quantum error correction for quantum memories. <italic toggle="yes">Rev. Mod. Phys.</italic><bold>87</bold>, 307 (2015).</mixed-citation></citation-alternatives></ref><ref id="CR48"><label>48.</label><mixed-citation publication-type="other">Barber, B. et al. A real-time, scalable, fast and highly resource efficient decoder for a quantum computer (2023),</mixed-citation></ref><ref id="CR49"><label>49.</label><mixed-citation publication-type="other">Liyanage, N., Wu, Y., Tagare, S. and Zhong, L., FPGA-based distributed union-find decoder for surface codes (2024),</mixed-citation></ref><ref id="CR50"><label>50.</label><mixed-citation publication-type="other">Das, P. et al. Afs: Accurate, fast, and scalable error-decoding for fault-tolerant quantum computers, in <italic toggle="yes">2022 IEEE International Symposium on High-Performance Computer Architecture (HPCA)</italic> (IEEE, 2022) pp. 259&#8211;273.</mixed-citation></ref><ref id="CR51"><label>51.</label><citation-alternatives><element-citation id="ec-CR51" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Herold</surname><given-names>M</given-names></name><name name-style="western"><surname>Campbell</surname><given-names>ET</given-names></name><name name-style="western"><surname>Eisert</surname><given-names>J</given-names></name><name name-style="western"><surname>Kastoryano</surname><given-names>MJ</given-names></name></person-group><article-title>Cellular-automaton decoders for topological quantum memories</article-title><source>npjqi</source><year>2015</year><volume>1</volume><fpage>15010</fpage></element-citation><mixed-citation id="mc-CR51" publication-type="journal">Herold, M., Campbell, E. T., Eisert, J. &amp; Kastoryano, M. J. Cellular-automaton decoders for topological quantum memories. <italic toggle="yes">npjqi</italic><bold>1</bold>, 15010 (2015).</mixed-citation></citation-alternatives></ref><ref id="CR52"><label>52.</label><citation-alternatives><element-citation id="ec-CR52" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Kubica</surname><given-names>A</given-names></name><etal/></person-group><article-title>Erasure qubits: Overcoming the <italic toggle="yes">T</italic><sub>1</sub> limit in superconducting circuits</article-title><source>Phys. Rev. X</source><year>2023</year><volume>13</volume><fpage>041022</fpage></element-citation><mixed-citation id="mc-CR52" publication-type="journal">Kubica, A. et al. Erasure qubits: Overcoming the <italic toggle="yes">T</italic><sub>1</sub> limit in superconducting circuits. <italic toggle="yes">Phys. Rev. X</italic><bold>13</bold>, 041022 (2023).</mixed-citation></citation-alternatives></ref><ref id="CR53"><label>53.</label><mixed-citation publication-type="other">Levine, H. et al. Demonstrating a long-coherence dual-rail erasure qubit using tunable transmons (2023), <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/arXiv:2307.08737">https://arxiv.org/abs/arXiv:2307.08737</ext-link> arXiv:2307.08737.</mixed-citation></ref><ref id="CR54"><label>54.</label><mixed-citation publication-type="other">Gu, S., Retzker, A. and Kubica, A., Fault-tolerant quantum architectures based on erasure qubits, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/arXiv:2312.14060">https://arxiv.org/abs/arXiv:2312.14060</ext-link> (2023).</mixed-citation></ref><ref id="CR55"><label>55.</label><citation-alternatives><element-citation id="ec-CR55" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Wu</surname><given-names>Y</given-names></name><name name-style="western"><surname>Kolkowitz</surname><given-names>S</given-names></name><name name-style="western"><surname>Puri</surname><given-names>S</given-names></name><name name-style="western"><surname>Thompson</surname><given-names>JD</given-names></name></person-group><article-title>Erasure conversion for fault-tolerant quantum computing in alkaline earth Rydberg atom arrays</article-title><source>Nat. Commun.</source><year>2022</year><volume>13</volume><fpage>4657</fpage><pub-id pub-id-type="pmid">35945218</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-022-32094-6</pub-id><pub-id pub-id-type="pmcid">PMC9363413</pub-id></element-citation><mixed-citation id="mc-CR55" publication-type="journal">Wu, Y., Kolkowitz, S., Puri, S. &amp; Thompson, J. D. Erasure conversion for fault-tolerant quantum computing in alkaline earth Rydberg atom arrays. <italic toggle="yes">Nat. Commun.</italic><bold>13</bold>, 4657 (2022).<pub-id pub-id-type="pmid">35945218</pub-id><pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-022-32094-6</pub-id><pub-id pub-id-type="pmcid">PMC9363413</pub-id></mixed-citation></citation-alternatives></ref><ref id="CR56"><label>56.</label><mixed-citation publication-type="other">Wolanski, S. &amp; Barber, B. Introducing ambiguity clustering: an accurate and efficient decoder for qldpc codes, Proc. IEEE Int. Conf. Quantum Comput. Eng. (QCE), Montreal, QC, Canada, pp. 402&#8211;403 10.1109/QCE60285.2024.10326 (2024).</mixed-citation></ref><ref id="CR57"><label>57.</label><mixed-citation publication-type="other">Pattison, C. QEC utilities for practical realizations of general qLDPC codes, <ext-link ext-link-type="uri" xlink:href="https://github.com/qldpc/exp_ldpc">https://github.com/qldpc/exp_ldpc</ext-link> (2024).</mixed-citation></ref><ref id="CR58"><label>58.</label><mixed-citation publication-type="other">Scruby, T.R., Hillmann, T. and Roffe, J., High-threshold, low-overhead and single-shot decodable fault-tolerant quantum memory, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2406.14445">https://arxiv.org/abs/2406.14445</ext-link> arxiv:2406.14445 [quant-ph] (2024).</mixed-citation></ref><ref id="CR59"><label>59.</label><mixed-citation publication-type="other">Gong, A., Cammerer, S. and Renes, J.M., Toward low-latency iterative decoding of QLDPC codes under circuit-level noise, <ext-link ext-link-type="uri" xlink:href="https://arxiv.org/abs/2403.18901">https://arxiv.org/abs/2403.18901</ext-link> arxiv:2403.18901 [quant-ph] (2024)</mixed-citation></ref><ref id="CR60"><label>60.</label><citation-alternatives><element-citation id="ec-CR60" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Simsiri</surname><given-names>N</given-names></name><name name-style="western"><surname>Tangwongsan</surname><given-names>K</given-names></name><name name-style="western"><surname>Tirthapura</surname><given-names>S</given-names></name><name name-style="western"><surname>Wu</surname><given-names>K-L</given-names></name></person-group><article-title>Work-efficient parallel union-find</article-title><source>Concurrency Comput.: Pract. Experience</source><year>2018</year><volume>30</volume><fpage>e4333</fpage></element-citation><mixed-citation id="mc-CR60" publication-type="journal">Simsiri, N., Tangwongsan, K., Tirthapura, S. &amp; Wu, K.-L. Work-efficient parallel union-find. <italic toggle="yes">Concurrency Comput.: Pract. Experience</italic><bold>30</bold>, e4333 (2018).</mixed-citation></citation-alternatives></ref><ref id="CR61"><label>61.</label><citation-alternatives><element-citation id="ec-CR61" publication-type="journal"><person-group person-group-type="author"><name name-style="western"><surname>Delfosse</surname><given-names>N</given-names></name><name name-style="western"><surname>Nickerson</surname><given-names>NH</given-names></name></person-group><article-title>Almost-linear time decoding algorithm for topological codes</article-title><source>Quantum</source><year>2021</year><volume>5</volume><fpage>595</fpage></element-citation><mixed-citation id="mc-CR61" publication-type="journal">Delfosse, N. &amp; Nickerson, N. H. Almost-linear time decoding algorithm for topological codes. <italic toggle="yes">Quantum</italic><bold>5</bold>, 595 (2021).</mixed-citation></citation-alternatives></ref><ref id="CR62"><label>62.</label><mixed-citation publication-type="other">Hillmann, T. et al. Simulation results for &#8220;Localized statistics decoding: A parallel decoding algorithm for quantum low-density parity-check codes", <ext-link ext-link-type="uri" xlink:href="https://zenodo.org/records/12548001">https://zenodo.org/records/12548001</ext-link> (2024).<pub-id pub-id-type="doi" assigning-authority="pmc">10.1038/s41467-025-63214-7</pub-id><pub-id pub-id-type="pmcid">PMC12405505</pub-id><pub-id pub-id-type="pmid">40897712</pub-id></mixed-citation></ref></ref-list></back></article>
        
    </metadata>
</record>
    </GetRecord>

</OAI-PMH>